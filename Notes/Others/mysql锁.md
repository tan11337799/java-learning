## 锁

### Myisam和Innodb在锁上的区别

**MyISAM**：MyISAM只有表锁，其中又分为共享读锁和独占写锁。

- MyISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。
- MyISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。
- MyISAM表的读、写操作之间、以及写操作之间是串行的。

**Innodb**行锁：共享锁，排他锁

- 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X）；对于普通SELECT语句，Innodb不会加任何锁。

```
//显示共享锁（S） ：
 SELECT * FROM table_name WHERE .... LOCK IN SHARE MODE
 //显示排他锁（X）：
 SELECT * FROM table_name WHERE .... FOR UPDATE.

```

- 记录锁（Record Locks）：记录锁是封锁记录，记录锁也叫行锁，注意：行锁是针对索引的，如果表中没有索引，那么就会锁整张表
- 间隙锁（GAP）对于键值在条件范围内但并不存在的记录，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。
- 临键锁（Next-Key Lock）：（Record Locks+GAP），锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

MYISAM适合的场景：

- 频繁执行全表count语句（用一个变量保存的表的行数）
- 对数据进行增删改的频率不高，查询非常频繁（因为非聚集索引）
- 没有事务

InnoDB适合的场景

- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务 



### 并发事务带来的问题

**更新丢失、脏读、不可重复读和幻读**

**更新丢失**

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改**。例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。

**脏读**

第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100，此时第一个事务做了回滚。最终第二个事务读取的变量和数据库的不一样。

**不可重复读**

T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

**幻读**

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。（和不可重复读的区别：一个是变量变化，一个是范围变化，重点在insert上）

### 数据库的隔离级别

首先，介绍四种隔离级别

**未提交读（Read-Uncommitted）**

事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.**可能会导致脏读、幻读或不可重复读**

**已提交读（Read-Committed）**

对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；**可以阻止脏读，但是幻读或不可重复读仍有可能发生**

**可重复读（Repeatable-Read）**

就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；**可以阻止脏读和不可重复读，但幻读仍有可能发生**

**可串行读（Serializable）**

对每一句增删改查都加锁，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；**该级别可以防止脏读、不可重复读以及幻读**

**其次**，MySQL InnoDB 存储引擎的默认支持的隔离级别是 **Repeatable-Read**（可重读）

其次，**这里需要注意的是**：与 SQL 标准不同的地方在于InnoDB 存储引擎在 Repeatable-Read（可重读）事务隔离级别 下使用的是**Next-Key Lock 锁**算法，锁定记录本身并且锁定一个范围，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别（误，其实并没有完全解决）。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）并不会有任何性能损失**。

#### InnoDB在RR隔离级别下已经可以避免幻读，为什么还需要串行化隔离级别

马有失蹄：InnoDB尽管会通过加Gap锁避免在锁定的数据周围插入数据，但依然会存在幻读的情况

1. a事务先select（此时是MVCC快照读），b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意操作）
2. a事务再select出来的结果在MVCC下还和第一次select一样，
3. 接着a事务不加条件地update，这个update会作用在所有行上，包括b事务新加的，因为update意味着开启了当前读
4. a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了.

MySQL官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读，所以这个场景下，就算出现幻读了。

如果一定要完全避免幻读要么开启串行化隔离级别，要么就不使用快照读，直接在读的时候就开启当前读，给相应的段数据加锁，避免插入，也就类似于串行化了，但是串行化的性能很差，同时幻读很多时候是可以被接受的，所以没必要就不这么做。

### 快照读和当前读

![image-20210321233947959](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210321233955.png)

快照读（就是不加锁的非阻塞读，就是最普通的select操作）不能是 Serializable级别的select（退化了，都加锁了），快照读有可能在RR级别下读到历史版本，创建快照的时机（RR下建立事务后首次使用快照读的地方，RC下每次调用快照读都会创建一个新的快照）决定了读取数据的版本。

### 什么是MVCC

MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。

当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。

### RC和RR级别下的InnoDB非阻塞读如何实现

InnoDB使用了类似MVCC的方法实现非阻塞读。

首先数据行中会有`DB_TRX_ID`,`DB_ROLL_PTR`和`DB_ROW_ID`三个字段，分别代表事务ID，回滚指针，和行ID（类似于主键，在聚簇索引没有指定主键和索引时生成的隐藏主键）

当我们对记录做了变更操作时，就会产生undo log记录，undo记录中存储的是老版数据，当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着undo中以上的三个列找到满足其可见性的记录，这个找满足可见行的记录依赖 read view

read view主要是用来做可见性判断的，即当我们去执行快照读 select 的时候，会针对我们查询的数据创建出一个 read view，来决定当前事务能看到的是哪个版本的数据，有可能是当前最新版本的数据，也可能是 undo log 中某个版本的数据，read view 遵循一个可见性算法。

![image-20210322000407950](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210322000408.png)

快照读在RC、RR级别中：RR下，事务在第一个Read操作时，会建立Read View（读不到数据变更），所以看时机。
RC下，事务在每次Read操作时，都会建立Read View

Innodb当前读是通过加Next Key Lock（即record lock(记录锁)和gap lock(间隙锁)的结合）来实现的。 innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!

为什么是伪MVCC，是因为undo log中记录的是串行化的事务过程结果，不属于多版本共存。



### 读写分离原理 

主库（master）将sql操作写入**binlog**日志，然后从库（slave）连接到主库之后，从库有一个**IO线程**，将主库的binlog日志**拷贝到自己本地**，写入relay log中。接着从库中有一个SQL线程会从relay log中读取内容并执行，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。

这里有一个非常重要的一点，就是从库同步主库数据的过程是**串行化**的，也就是说**主库上并行**的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

所以mysql实际上在这一块有两个机制，一个是**半同步复制**，用来解决主库数据丢失问题；一个是**并行复制**，用来解决主从同步延时问题。

**半同步复制**：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，

**并行复制**：从库**开启多个线程，并行读取relay log中不同库的日志并执行**，本质是同时执行的SQL不存在锁争用。

### MVCC,redolog,undolog,binlog

- undoLog 也就是我们常说的**回滚日志文件** 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如"把id=‘B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =‘B’的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事务用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。
- redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。
- MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。
- binlog由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如"把id=‘B’ 修改为id = ‘B2’。binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。 产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复。

#### binlog和redolog的区别

1. redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。
2. 两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。
3. 两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。
4. binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。
5. binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。

#### 二阶段提交

当数据写入时

一阶段是对redo log写，然后redo log进入prepare状态

二阶段是对binlog写，然后提交事务，redo log进入commit状态

这样的好处在于MySQL出现问题时，避免日志恢复的数据出现不一致的情况。

如果先写redolog，写完直接置为commit，然后再写binlog，在中间发生宕机时，系统利用redolog恢复的数据就会比binlog中记录的数据要多一条，出现数据不一致的情况。

如果先写binlog，再写redolog，如果写redo log时MySQL宕机了，那么binlog上的记录就会比磁盘上记录的数据多一条记录，在用binlog做恢复数据时或者主从同步时，就会导致主从之间数据不一致的情况。

利用二阶段提交可以避免这种情况。

## 解决哈希冲突的四种方法

1.开放地址方法：（1）线性探测  （2）再平方探测 （3）伪随机探测

2.链式地址法（HashMap的哈希冲突解决方法）

3.建立公共溢出区

4.再哈希法

