---
typora-root-url: assets
typora-copy-images-to: assets
---



# MySQL

### 基础

**文件结构**

      		1. 安装目录
           * 配置文件 my.ini
    	2. MySQL数据目录：datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
  * 数据库：文件夹
  * 表：文件
  * 数据：数据




**语法**

* SQL语句可以单行或多行书写，以分号结尾；
* 可以使用空格和缩进增强语句的可读性；
* MySQL 数据库的 SQL 语句不区分大小写，**关键字**建议使用大写。
* 3 种注释
    * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
   * 多行注释: /* 注释 */
   * SQL主要完成：C：Create	 R:Retrieve	 U:Update	 D:Delete



**数据类型**

整数类型：int

小数类型：float、double

日期类型：date(yyyy-MM-dd)、datatime(yyyy-MM-dd HH:mm:ss)、timestamp(yyyy-MM-dd HH:mm:ss，timestamp类型如果不给该字段赋值，或赋值为null，默认使用当前的系统时间自动赋值)

字符串类型：varchar



**分类**

* DDL(Data Definition Language)数据定义语言
  用来定义数据库对象：数据库，表，列等。**关键字：create, drop, alter**
* DML(Data Manipulation Language)数据操作语言
  用来对数据库中表的数据进行增删改。**关键字：insert, delete, update**
* DQL(Data Query Language)数据查询语言
  用来查询数据库中表的记录(数据)。**关键字：select, where**
* DCL(Data Control Language)数据控制语言(了解)
  用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等





### 安装

windows下较为简单不记录，下面主要介绍Linux下的安装。

**第一步**

将官网下载的MySQL安装包解压：

```shell
mkdir mysql
tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql
```

**第二步**

安装解压得到的rpm文件：

```bash
cd mysql
rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm
yum install openssl-devel 
rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm
rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm
```

**第三步**

启动mysql服务：`systemctl start mysqld;`

**第四步**

查询自动生成的root用户密码 `grep 'temporary password' /var/log/mysqld.log`

用临时密码登陆mysqld：`mysql -u root -p`

**第五步**

修改root密码策略：

```bash
set global validate_password.policy = 0;
set global validate_password.length = 4;
```

修改密码（最低四位）：

`ALTER  USER  'root'@'localhost'  IDENTIFIED BY '1234';`

**第六步**

为远程访问创建用户：`create user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '1234';`

为root用户分配权限：`grant all on *.* to 'root'@'%';`

**第七步**

查看防火墙状态：`systemctl status firewalld.service`

开放防火墙3306端口：`firewall-cmd --zone=public --add-port=【portnum】/tcp --permanent`

重载防火墙配置（开放端口永久生效）：`firewall-cmd --reload`

在本地端连接该服务器



### 体系结构

MySQL 的架构共分为两层：**Server 层和存储引擎层**，

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

![1654418669796](/1654418669796.png)

结构：连接层-服务层-引擎层-存储层

![1654436740189](/1654436740189.png)



**连接层**

通过TCP三次握手启动MySQL服务，连接器负责验证用户名和密码。

如果用户名或密码不对，就收到一个"Access denied for user"的错误，然后客户端程序结束执行。

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。（所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置）

**问题1：空闲连接会一直占用着吗？**

MySQL 定义了空闲连接的最大空闲时长，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。

一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

**问题2：MySQL 的连接数有限制吗？**

MySQL 服务支持的最大连接数由 max_connections 参数控制，比如 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：

```
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。

**问题3：怎么解决长连接占用内存的问题？**

第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，客户端主动重置连接。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



**查询缓存**

连接器工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。

如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。

如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。所以，MySQL 8.0 版本直接将查询缓存删掉了。



**解析器**

在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由解析器来完成，解析器会做如下两件事情。

第一件事情，词法分析。MySQL 会根据输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

第二件事情，语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果我们输入的 SQL 语句语法不对，或者数据表或者字段不存在，都会在解析器这个阶段报错。



**查询优化器**

经过解析器后，接着就要执行 SQL 查询语句了，但是在真正执行之前，会检查用户是否有访问该数据库表的权限，如果没有就直接报错。

如果有权限，就进入 SQL 查询语句的执行阶段，而 SQL 查询语句真正执行之前需要先制定一个执行计划，这个工作交由「优化器」来完成的。

优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。



**执行器**

经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。



### 底层

**查询语句的过程**

- 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL 8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过分析器进行词法分析，提取 sql 语句的关键元素，比如 select，需要查询的表名，需要查询的列，以及查询条件。然后判断这个 sql 语句是否有语法错误，如果检查没问题就执行下一步。
- 接下来就是优化器进行确定执行方案，它会根据自己的优化算法进行选择它认为执行效率最好的一个方案。确认了执行计划后就准备开始执行了。
- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

**插入语句的过程**

- 先查询这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把数据更改好，然后调用存储引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 bin log，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成。



---



# 操作

### 操作库和表（DDL）

##### 配置

**windows:**

打开服务：`net start mysql`

关闭服务：`net stop mysql`

连接mysql：`mysql -u[user] -p[password]`	（u和p后面为自己设置的账户密码）

连接mysql(隐私)：`mysql -u[user] -p`	（需要输入密码）

查看客户端连接情况：`show processlist`

远程连接mysql：`mysql -h[ip] -u[user] -p`

同上：`mysql –host=[ip] --user=[user] --password==[password]`

退出mysql：`exit` 或 `quit`

**linux:**

`systemctl start mysqld`   启动MYSQL服务

`systemctl restart mysqld`   重启MYSQL服务

`systemctl stop mysqld`   关闭MYSQL服务



##### 操作

**查询 SHOW**

查询数据库：

`show databases;`	查看所有的数据库名称

`select database();`	查询当前正在使用的数据库

`show create database 数据库名称;`	查询某个数据库的字符集（创建语句）

查询表：

`show tables;`	查看某个数据库中的所有表名称

`desc table1;`	查询表结构

`show create table 表名;`	查看建表语句



**创建 CREATE**

创建数据库：

`create database [if not exists] db1 [character set 字符集];`	创建数据集db1

创建表：

语法：

```mysql
create table t1(
	列1 数据类型1 [comment 注释1]，
	列2 数据类型2 [comment 注释2]，
	...
	列n 数据类型n [comment 注释n]
);# 最后一行不需要逗号
```

或使用复制来创建：`create table 复制表的表名 like 表名;`

数据类型创建格式：

- 整数： `age int;`
- 小数：`score double(5,2);`    小数最多五位，小数点后保留两位小数
- 日期：`birth date;`
- 字符串：`name varchar(20);`     规定最长的字符个数

举例：

```mysql
create table 表名(
	id int,
    name varchar(32),
    age int,
    score double(4,1),
    birthday date,
    insert_time timestamp
);
```



**修改 ALTER**

修改数据库：

`alter database db1 character set gbk;`	将数据库db1的字符集类型修改为gbk

修改表：

`alter table 表名 rename to 新表名;`	将表名重命名为新表名

`alter table 表名 character set utf8;`	修改表名的字符集为utf8

`alter table 表名 add 字段名 新数据类型;`	给指定表添加一个新字段

`alter table 表名 change 字段名 新字段名 新数据类型; `	修改字段名称和类型

`alter table 表名 modify 字段名 新数据类型;`	只修改字段的类型



**删除 DROP**

`drop database [if exists] db1;`	删除数据库db1

`drop table [if exsits] 表名;`	删除表



**其他**

`mysqldump -u用户名 -p密码 > 保存路径;`	备份当前的数据库

`source sql文件路径;`		还原数据库

`use db1;`	选择使用的数据库



---



### 操作数据（DML）

任务：增删改表中的数据。

添加数据 INSERT

语法：`insert into 表名(column1,column2,...) values(val1, val2, val3...);`

注意点：

* 字段名和值要一一对应；
* 如果表名后，不定义字段名`(c1,c2,…)`，则默认给所有字段添加值（必须保证val个数等于字段数）；



**删除数据 DELETE**

**语法：**`delete from 表名 [where 条件];`	在指定条件下删除数据

**举例：**`delete from stu where id=1;`		删除id=1的数据

**注意点：**

* 如果不加where条件，则删除表中的所有记录（不建议使用)；

* 我们一般使用`truncate table 表名;`删除表中的所有数据，truncate会删除表并创建一个一样的空表

  > truncate 与delete 比较： 
  >
  > truncate table 在功能上与不带 WHERE 子句的 delete语句相同：二者均删除表中的全部行。
  >
  > truncate 比 delete速度快，且使用的系统和事务日志资源少。
  >
  > 当表被清空后表和表的索引讲重新设置成初始大小，而delete则不能。



**修改数据  UPDATE**

**语法：**`update 表名 set column1=val1,column2=val2.... [where 条件];`

**举例：**`update stu set age=17,score=98 where id=1;`	修改id=1数据中age和score的值

**注意点：**

* 如果不加where条件，则会修改表中的所有记录（不建议使用）；



---



### 查询数据（DQL）

**语法：**

```mysql
select
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段
having
	分组之后的条件
order by
	排序
limit
	分页限定
```



##### 函数

**字符串函数**

| 函数                       | 功能                                                      |
| -------------------------- | --------------------------------------------------------- |
| CONCAT(s1, s2, …, sn)      | 字符串拼接，将s1, s2, …, sn拼接成一个字符串               |
| LOWER(str)                 | 将字符串全部转为小写                                      |
| UPPER(str)                 | 将字符串全部转为大写                                      |
| LPAD(str, n, pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
| RPAD(str, n, pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
| TRIM(str)                  | 去掉字符串头部和尾部的空格                                |
| SUBSTRING(str, start, len) | 返回从字符串str从start位置起的len个长度的字符串           |

使用示例：

```mysql
-- 拼接
SELECT CONCAT('Hello', 'World');
-- 小写
SELECT LOWER('Hello');
-- 大写
SELECT UPPER('Hello');
-- 左填充
SELECT LPAD('01', 5, '-');
-- 右填充
SELECT RPAD('01', 5, '-');
-- 去除空格
SELECT TRIM(' Hello World ');
-- 切片（起始索引为1）
SELECT SUBSTRING('Hello World', 1, 5);
```

**数值函数**

| 函数        | 功能                             |
| ----------- | -------------------------------- |
| CEIL(x)     | 向上取整                         |
| FLOOR(x)    | 向下取整                         |
| MOD(x, y)   | 返回x/y的模                      |
| RAND()      | 返回0~1内的随机数                |
| ROUND(x, y) | 求参数x的四舍五入值，保留y位小数 |

**日期函数**

| 函数                               | 功能                                              |
| ---------------------------------- | ------------------------------------------------- |
| CURDATE()                          | 返回当前日期                                      |
| CURTIME()                          | 返回当前时间                                      |
| NOW()                              | 返回当前日期和时间                                |
| YEAR(date)                         | 获取指定date的年份                                |
| MONTH(date)                        | 获取指定date的月份                                |
| DAY(date)                          | 获取指定date的日期                                |
| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
| DATEDIFF(date1, date2)             | 返回起始时间date1和结束时间date2之间的天数        |

例子：

```
-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);
```

**流程函数**

| 函数                                                         | 功能                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| IF(value, t, f)                                              | 如果value为true，则返回t，否则返回f                     |
| IFNULL(value1, value2)                                       | 如果value1不为空，返回value1，否则返回value2            |
| CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END      | 如果val1为true，返回res1，… 否则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END | 如果expr的值等于val1，返回res1，… 否则返回default默认值 |

**例子：**

```mysql
select name, (case when age > 30 then '中年' else '青年' end)from employee;
select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'from employee;
```





##### 基础查询

**查询多个字段**

`select 字段1,字段2,... from 表名;  `

注意点：我们可以使用*号替代整个字段列表

**去除重复**

`select distinct 字段列表 from 表名;`	

注意点：如果字段有多列，则只会去除每一列都相等的行

**计算列的表达式（四则运算）**

`select 字段1,字段2,expression(字段1,字段2) from 表名;`	

`select 字段1,字段2,expression(IFNULL(字段1,0)+IFNULL(字段2,0)) from 表名; `   避免NULL参与计算

注意点：（1）如果有NULL参与计算，则计算结果都为NULL；（2）mysql中可以使用ifnull返回相应结果：ifnull(c1,0)表示如果c1为null则用0替代

**起别名**

我们一般会给表起别名。

`select 字段1,字段2,expression(IFNULL(字段1,0)+IFNULL(字段2,0)) [as] 别名 from 表名;` 



**聚合函数**

将一列数据作为一个整体，进行**纵向**的计算。包括以下几种：

count: 计算个数

max: 计算最大值

min: 计算最小值

sum: 求和

avg: 计算平均值

**语法：**`SELECT 聚合函数(字段列表) FROM 表名;`

**例：**`SELECT count(id) from employee where workaddress = "广东省";`

**注意点：**

- 聚合函数会排除null值：（1）选择不包含非空的列（主键）进行计算；（2）我们使用IFNULL函数去除NULL；



##### 高级查询

**条件查询 WHERE**

**语法：**`SELECT 字段列表 FROM 表名 WHERE 条件列表;`

**运算符**

* `>,<,>=,<=,=,<>`     判断运算符（在mysql中使用<>表示不等于，也可以使用!=）
* `LIKE "%c%"`    模糊查询（最为常用）
* `IS (NOT) NULL`    空/非空判断（不能使用等号判断NULL）
* `IN(val1,val2,...)`   ()可以表示一个集合
* `BETWEEN…AND`    在一个范围内（包含边界）
* `and(&&),or(||),not(!)`    逻辑运算符

**举例**

```mysql
# 查询年龄不等于20的数据
SELECT * FROM student WHERE age!=20;
SELECT * FROM student WHERE age<>20;
# 查询年龄在20-30之间数据
SELECT * FROM student WHERE age>=20 AND age<30;
SELECT * FROM student WHERE age BETWEEN 20 AND 30;
# 查询年龄为22/19/25岁的信息
SELECT * FROM student WHERE age=22 OR age=19 OR age=25;
SELECT * FROM student WHERE age IN(22,19,25);
# 查询有/没有英语成绩的信息
# (语句错误，不能使用等号判断NULL)SELECT * FROM student WHERE english=NULL;
SELECT * FROM student WHERE english IS NULL;
SELECT * FROM student WHERE english IS NOT NULL;
# 模糊查询（常用）
SELECT * FROM student WHERE NAME LIKE "马%";    # 表示查询name为 马 开头的信息
SELECT * FROM student WHERE NAME LIKE "_化%";    # 表示查询第二个字为 化 的信息
SELECT * FROM student WHERE NAME LIKE "___";    # 表示查询name为三个字符的信息
SELECT * FROM student WHERE NAME LIKE "%马%";    # 表示查询name中包含 马 的信息
```



**排序查询 ORDER BY**

**语法：**`SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;`

* 当有多个排序条件时：`order by 排序字段1 排序方式1, 排序字段2 排序方式2…;`（只有前面的条件判断相同才判断后续条件）

**排序方式：**

* ASC：升序，默认
* DESC：降序

**具体：**

`select * from table order by 字段 (ASC);`    根据字段按升序排列（可将ASC省略）

`select * from table order by 字段 DESC;`    根据字段按降序排列

`select * from table order by 字段1 ASC/DESC, 字段2 ASC/DESC;`     按字段1排列，如果字段1相同则按字段2排列



**分组查询  GROUP BY**

**语法：**`SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];`

**注意点：**分组之后需要查询字段：**需要分组的字段**、**聚合函数**；加其他字段没有任何意义；

**限定条件：**

* `where 条件语句`    
  * 放在**group by之前**进行限定，如果不满足结果的**数据**则**不参加分组**；
  * where中不可以跟聚合函数
* `having 条件语句`    
  * 放在**group by之后**进行限定，如果不满足结果的**分组**则**不会被查询**；
  * having中可以进行聚合函数的判断

**举例：**

```mysql
SELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex;
SELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex HAVING COUNT(id)>2;	# 使用having限定，此时分组中会去除不满足条件的分组
SELECT sex,AVG(math),COUNT(id) FROM student WHERE math>70 GROUP BY sex;	# 使用where限定，此时select后的查询值只会计入符合where条件的数据
```



**分页查询 LIMIT**

**语法：**`SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; `

**公式：**`开始的索引=(当前页码-1)*每页显示的条数`

LIMIT分页是一种“方言”，在各类数据库中不同

**举例：**

```mysql
SELECT * FROM student LIMIT 0,3;# 第一页
SELECT * FROM student LIMIT 3,3;# 第二页
SELECT * FROM student LIMIT 6,3;# 第三页
```



---



### 用户管理（DCL）

DCL用于管理数据库用户，控制数据库的访问权限。这类操作SQL开发人员较少使用，主要是运维负责使用。

##### 管理

**查询用户：**

```mysql
USE mysql;
SELECT * FROM user;
```

**用户管理：**

```mysql
-- 添加用户
create user '用户名'@'主机名' identified by '密码';
-- 修改密码
update user set password=password('修改密码') where user='指定用户名';
-- ALTER  USER  'root'@'localhost'  IDENTIFIED BY '1234';
flush privileges; # 刷新权限，必须添加
-- 删除用户
DROP USER '用户名'@'主机名'; # 需要指定主机，否则只会删除任意主机的用户
```

**例子：**

```mysql
-- 创建用户test，只能在当前主机localhost访问
create user 'itcast'@'localhost' identified by '123456';
-- 创建用户test，能在任意主机访问
create user 'itcast'@'%' identified by '123456';
create user 'itcast' identified by '123456'; # 不添加指定主机默认为全部主机均可访问
-- 修改密码
update user set password=password('1234') where user='itcast';
flush privileges;# 刷新权限，必须添加
-- 删除用户
drop user 'itcast'@'localhost'; # 不添加指定主机会默认删除%的主机
```



##### **忘记密码**

* 关闭正在运行的MySQL服务。
* 打开DOS窗口，转到mysql\bin目录。输入`mysqld --skip-grant-tables`，启动MySQL服务的时候跳过权限表认证。
* 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），进入mysql。
* 连接权限数据库： `use mysql; `
* 修改密码：`update user set password=password(“root”) where user=“root”;`
  刷新权限（必须步骤）：`flush privileges;`　



##### 权限控制

**常用权限：**

| 权限                | 说明               |
| ------------------- | ------------------ |
| ALL, ALL PRIVILEGES | 所有权限           |
| SELECT              | 查询数据           |
| INSERT              | 插入数据           |
| UPDATE              | 修改数据           |
| DELETE              | 删除数据           |
| ALTER               | 修改表             |
| DROP                | 删除数据库/表/视图 |
| CREATE              | 创建数据库/表      |

更多权限请看[权限一览表](https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8)

**语法：**

`show grants;`	查询当前用户的权限

`SHOW GRANTS FOR '用户名'@'主机名';`	查询指定用户的权限

`GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';`    授予指定用户权限

`REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';`	撤销指定用户的权限



**注意事项：**

- 多个权限用逗号分隔
- 授权时，数据库名和表名可以用 * 进行通配，代表所有



---



# 约束

### 概念

约束用于对表中的数据进行限定，保证数据的正确性、有效性和完整性。

**分类：**

* 主键约束：primary key
* 非空约束：not null
* 唯一约束：unique
* 外键约束：foreign key



### **约束的添加**

约束的添加一般有表创建时或创建表后两种方式设定

**语法：**

* 创建表时：

  ```mysql
  CREATE TABLE stu(
  	id INT PRIMARY KEY auto_increment, -- 设置id为主键并自动增长
  	NAME VARCHAR(20) NOT NULL,
      phone_number VARCHAR(20) UNIQUE
  );
  ```

* 创建表后：

  添加非空约束：`ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;`

  去除非空约束：`ALTER TABLE stu MODIFY NAME VARCHAR(20);`

  添加唯一约束：`ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;`

  去除唯一约束：`ALTER TABLE stu DROP INDEX phone_number;`

**注意点：**

* **非空约束**如果数据中需要设定的列本来有NULL则无法在创建表后设定；
* **唯一约束**允许数据出现NULL值，但不允许出现第二个NULL值；
* 给**主键约束**的列设置自动增长后，原本不可为NULL的值允许为NULL值；



### 主键约束

**介绍**

主键是是数据表中记录的唯⼀标识。

**注意点：**

- 主键非空且唯一
- 一张表只能有一个字段为主键，被添加主键约束的字段被称为主键字段；

**语法：**`PRIMARY KEY / AUTO_INCREMENT`

* 创建表前：

  ```mysql
  CREATE TABLE stu(
  	id INT PRIMARY KEY auto_increment, -- 设置id为主键并自动增长
  );
  ```

* 创建表后：

  添加主键约束：`ALTER TABLE stu MODIFY id INT PRIMARY KEY;`

  去除主键约束：`ALTER TABLE stu DROP PRIMARY KEY;`

  添加自动增长：`ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;`

  去除自动增长：`ALTER TABLE stu MODIFY id INT;`



**自动增长**

**概念：**如果某一列数据是数值类型，可以使用自动增长完成值的自增

**注意点：**

- 自动增长一般用于主键，也可以用于非主键（较少）；
- 自动增长列数据的添加可以不设置，也可以设置为NULL（不管是不是主键）；
- 自增只会根据上一条记录的值+1，而不会记录真实的长度



### 外键约束

**介绍**

外键约束是在父子表关系中体现的一种约束操作，其用于让表和表产生关系，从而保证数据的正确性。

**注意点：**

- 外键字段依赖于已经存在的表的一个主键，所以一定要先有主表
- 外键字段必须和主表的主键字段的数据类型要相似：如果是数值型，两者必须类型一致，并且同时为有无符号；如果是字符串型，两者的长度可以不同，但是类型必须相同。
- 如果子表的外键字段没有创建索引，但是当我们创建完外键之后，它会自动的添加索引。
- 如果子表中有记录外键关联着主表中的记录：（1）主表中的这条记录以及主表无法删除；（2）子表中的这些记录可以删除；（3）也不能在子表的外键中添加不是来自该主表列的记录

**语法：**

* 创建表时：

  ```mysql
  create table 子表名(
  	...
  	外键列,
  	constraint 外键名称【自己取名】 foreign key (外键列名称) references 主表名称(主表列名称【一般为主键】)
  );
  ```

* 创建表后：

  添加外键：` ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称); `

  删除外键：`ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;`

**举例：**

```mysql
-- 创建表时添加外键约束
CREATE TABLE department(
	id INT PRIMARY KEY,
	dep_name VARCHAR(20),
	dep_location VARCHAR(20)
);# 一定要先创建主表，才能给子表添加外键约束
CREATE TABLE employee(
	id INT PRIMARY KEY,
	NAME VARCHAR(20),
	dep_id INT,
	CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id)
);
-- 创建表后添加和删除外键约束
ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;-- 删除外键
ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id);-- 添加外键
```



**级联操作**

**语法：**`ON UPDATE CASCADE`

设置级联更新：`ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE;`

删除级联更新：`ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称) ON DELETE CASCADE;`



---



# 数据库的设计

### 多表关系

可以分为：一对一、一对多、多对多

**一对一**

如：人和身份证

实现方式：在任意一方添加**唯一外键**，指向另一方的**主键**。（实际是多余操作）

**一对多**

如：部门与员工

实现方式：在多的一方建立**外键**，指向一的一方的**主键**。

**多对多**

如：学生和课程

实验方式：借助第三张中间表，中间表至少包含两个字段，分别指向两张表的主键。



### 数据库设计范式

**概念**

设计关系数据库时，需要遵从不同的规范要求，设计出合理的关系数据库。这些规范要求被称为**范式**，各类范式逐次规范，**越高的范式数据冗余度越小**。

**分类：**关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）、第五范式（5NF，完美范式）【一般满足前三范式即可基本满足数据库设计要求】

**名词解释：**

- **函数依赖：**通过A属性（属性组）的值，可以唯一确定B属性的值，称B依赖于A；【如：学号 => 姓名】
- **完全函数依赖：**如果A是一个属性组，则B属性值的确定需要依赖于A属性组中的所有属性值；【如：（学号，课程） => 分数】
- **部分函数依赖：**如果A是一个属性组，则B属性值的确定只需要依赖A属性组中的某一些值即可；【如：（学号，课程）=> 姓名】
- **传递函数依赖：**如果A属性（属性组），可以唯一确定B属性的值，再通过B属性（属性组）可以唯一确定C属性的值，则称C传递依赖于A；【如：学号=>系名=>系主任】
- **主关键字（码）：**如果一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的主关键字（码）；



**第一范式**

强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。



**第二范式**

在满足第一范式的基础上，要求非主属性完全依赖于主关键字（可能由多个属性组成）。

**目的：**在第一范式的基础上消除非主属性对主关键字的部分函数依赖，消除冗余。

**实现：**做表的拆分，直到每个表中每个非主属性都完全依赖于主关键字（不存在部分依赖于主关键字的属性）



**第三范式**

在满足第二范式的基础上，任何非主属性不依赖于其它非主属性。

**目的：**在第二范式的基础上消除传递依赖。

**实现：**做表的拆分，直到每个表的每个非主属性都不依赖于其他非主属性



----



# 多表查询

**笛卡尔积：**

* 有两个集合A、B，取这两个集合的所有组成情况。
* 要完成多表查询，需要消除无用的数据

**多表查询正确方式：**

* 为了避免笛卡尔积， 可以在 WHERE 加入有效的连接条件；
* 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表；
* 可以给表起别名，在SELECT和WHERE中使用表的别名；



### **内连接查询**

**分类：**可以分为隐式内连接和显式内连接两种。

**查询思路：**

- 从哪些表查询数据？
- 条件是什么？
- 查询哪些字段？

**隐式内连接：**

**目的：**用where条件消除无用的数据

**语法：**`select * from 表1,表2,… where 表1.prop=表2.prop;`

**举例：**

```mysql
-- 查询所有员工信息和对应的部门信息
SELECT * FROM dept,emp WHERE dept.`id`=emp.`dept_id`;
-- 查询员工表的名称，性别。部门表的名称
SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

-- 起别名
SELECT 
    t1.name, -- 员工表的姓名
    t1.gender,-- 员工表的性别
    t2.name -- 部门表的名称
FROM
	emp t1,
	dept t2
WHERE 
	t1.`dept_id` = t2.`id`;
```

**显式内连接：** 

**语法：**`select 字段列表 from 表名1 [inner join] 表名2 on 条件;`

**举例：**

```mysql
SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	# INNER可加可不加
SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	
```



### **外连接查询**

**分类：**可以分为左外连接和右外连接两种。

**左外连接（常用）：**

左外连接查询的是左表所有数据以及其交集部分。

**语法：**`select 字段列表 from 表1 left [outer] join 表2 on 条件;`

**举例：**

```mysql
-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
SELECT 	
	t1.*,t2.`name` 
FROM 
	emp t1 LEFT JOIN dept t2 
ON 
	t1.`dept_id` = t2.`id`;
```

**右外连接：**

右外连接查询的是右表所有数据以及其交集部分。

**语法：**`select 字段列表 from 表1 right [outer] join 表2 on 条件;`

**举例：**

```mysql
SELECT 	
	t1.*,t2.`name` 
FROM 
	emp t1 RIGHT JOIN dept t2 
ON 
	t1.`dept_id` = t2.`id`;
```



### 自连接查询

当前表与自身的连接查询，自连接必须使用表别名

**语法：**`SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;`

自连接查询，可以是内连接查询，也可以是外连接查询

**例子：**

```mysql
-- 查询员工及其所属领导的名字
select a.name, b.name from employee a, employee b where a.manager = b.id;
-- 没有领导的也查询出来
select a.name, b.name from employee a left join employee b on a.manager = b.id;
```



### 子查询

SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。
`SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);`

**举例：**

```mysql
-- 查询最高工资员工的信息
SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);
```

**子查询的不同情况：**

* 标量子查询（子查询的结果为单行单列）：

  子查询返回的结果是单个值（数字、字符串、日期等）。
  常用操作符：- < > > >= < <=子查询可以作为条件，使用运算符（大于小于等于）进行判断。

  举例：`select * from emp where emp.salary<(select AVG(salary) from emp);` 查询员工工资小于平均工资的员工

* 列子查询（子查询的结果是多行单列）：

  子查询可以作为条件，可以使用运算符in来判断（in是用于集合判断的关键字）

  需求：查询部门为财务部或市场部的员工

  `SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');` 

* 行子查询（子查询的结果是单行多列）：

* 表子查询（子查询的结果是多行多列）：

  需求：查询员工入职日期是2011.11.11之后的员工信息和部门信息

  ```mysql
  # 使用子查询
  SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2 WHERE t1.id = t2.dept_id;
  # 使用普通内连接（更好理解）
  SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11';
  ```


### 练习题

表的创建

```mysql
-- 部门表
CREATE TABLE dept (
  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
  dname VARCHAR(50), -- 部门名称
  loc VARCHAR(50) -- 部门所在地
);

-- 添加4个部门
INSERT INTO dept(id,dname,loc) VALUES 
(10,'教研部','北京'),
(20,'学工部','上海'),
(30,'销售部','广州'),
(40,'财务部','深圳');

-- 职务表，职务名称，职务描述
CREATE TABLE job (
  id INT PRIMARY KEY,
  jname VARCHAR(20),
  description VARCHAR(50)
);

-- 添加4个职务
INSERT INTO job (id, jname, description) VALUES
(1, '董事长', '管理整个公司，接单'),
(2, '经理', '管理部门员工'),
(3, '销售员', '向客人推销产品'),
(4, '文员', '使用办公软件');

-- 员工表
CREATE TABLE emp (
	id INT PRIMARY KEY, -- 员工id
	ename VARCHAR(50), -- 员工姓名
	job_id INT, -- 职务id
	mgr INT , -- 上级领导
	joindate DATE, -- 入职日期
	salary DECIMAL(7,2), -- 工资
	bonus DECIMAL(7,2), -- 奖金
	dept_id INT, -- 所在部门编号
	CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
	CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 添加员工
INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);

-- 工资等级表
CREATE TABLE salarygrade (
	grade INT PRIMARY KEY,   -- 级别
	losalary INT,  -- 最低工资
	hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
(1,7000,12000),
(2,12010,14000),
(3,14010,20000),
(4,20010,30000),
(5,30010,99990);

```

题目：

```mysql
-- 需求1：查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
SELECT 
	t1.`id`,t1.`ename`,t1.`salary`,t2.`jname`,t2.`description` 
FROM 
	emp t1,job t2 
WHERE 
	t1.`job_id`=t2.`id`;

-- 需求2：查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
SELECT 
	t1.`id`,t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`
FROM 
	emp t1,job t2,dept t3
WHERE 
	t1.`job_id`=t2.`id` AND t1.`dept_id`=t3.`id`;
	
-- 需求3：查询员工姓名、工资和工资等级
SELECT 
	t1.`ename`,t1.`salary`,t2.`grade`
FROM
	emp t1,salarygrade t2
WHERE
	t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
	
-- 需求4：查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
SELECT 
	t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`,t4.`grade`
FROM
	emp t1,job t2,dept t3,salarygrade t4
WHERE
	t1.`job_id`=t2.`id` AND t1.`dept_id`=t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;

-- 需求5：查询出部门编号、部门名称、部门位置、部门人数
SELECT 
	t1.`id`,t1.`dname`,t1.`loc`,t2.`total`
FROM
	dept t1,
	(
		SELECT 
			dept_id,COUNT(id) total
		FROM
			emp
		GROUP BY 
			dept_id
	) t2
WHERE
	t1.`id` = t2.dept_id;
	
-- 需求6：查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
SELECT
	t1.`id`,t1.`ename`,t2.`mgr`,t2.`ename`
FROM
	emp t1 LEFT JOIN emp t2

ON
	t1.`mgr` = t2.`id`;
```



---



# 事务

### 概念

如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

**操作**

查看/设置事务提交方式：

```mysql
select @@autocommit;
set @@autocommit=0;# 0为关闭自动提交操作；1为打开自动提交操作
```

开启事务： `start transaction;`

回滚：`rollback;`

提交：`commit;`

**举例：**

```mysql
start transaction;  -- 开启事务
update account set money = money-1000 where name='张三';
qwe  -- 发生错误，此时事务不会继续执行，需要选择commit或rollback
update account set money = money+1000 where name='李四';
commit;
rollback;
```



### 四大特征

**概念**

- 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败
- 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态
- 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的



**保证一致性**

- **从数据库层面**，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。**数据库必须要实现AID三大特性，才有可能实现一致性**。例如，原子性无法保证，显然一致性也无法保证。
- **从应用层面**，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

**保证原子性**

OK，是利用Innodb的**undo log**。 **undo log**名为回滚日志，是实现原子性的关键，他需要记录你要回滚的相应日志信息，当事务回滚时能够撤销所有已经成功执行的sql语句。 例如

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

**undo log**记录了这些回滚需要的信息，当事务执行失败或调用了**rollback**，导致事务需要回滚，便可以利用**undo log**中的信息将数据回滚到修改之前的样子。

**保证持久性**

利用Innodb的**redo log**。在更改数据时，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用**redo log**解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在**redo log**中记录这次操作。当事务提交的时候，会将**redo log**日志进行刷盘(**redo log**一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据**undo log**和**binlog**内容决定回滚数据还是提交数据。

**采用redo log的好处？**

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

**保证隔离性**

利用的是锁和MVCC机制。



并发事务问题

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没提交的数据<br />（举例：第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100） |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同<br />（举例：T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同） |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是再insert数据时，又发现这行数据已经存在<br />（举例：T1 读取某个范围的数据，没有对应的数据行；T2 在这个范围内插入新的数据并提交；T1 插入数据时，发现此数据行已存在，进行查询却发现该数据不存在） |

>幻读和不可重复读的区别：不可重复读是由于另一个事务对数据的UPDATE和DELETE所造成的，而幻读是由于另一个事务INSERT数据引起的



### 隔离级别

| 隔离级别              | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| Read uncommitted      | √    | √          | √    |
| Read committed        | ×    | √          | √    |
| Repeatable Read(默认) | ×    | ×          | √    |
| Serializable          | ×    | ×          | ×    |

- Serializable 性能最低，数据安全性最好；Read uncommitted 性能最高，数据安全性最差

- 可重复读是MySQL数据库的默认级别，而读已提交是其他数据库的常见默认级别。


**语法：**

查看事务隔离级别：`SELECT @@tx_isolation;`

设置事务隔离级别：`SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };`SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效



---



# 存储引擎

### 概念

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。

MySQL默认存储引擎是InnoDB。



**语法**

`CREATE TABLE 表名( 表内容 ) ENGINE=指定存储引擎;` 	创建表时选择存储引擎

`show engines;`	显示当前数据库文件支持的存储引擎



### 三大引擎

**InnoDB**

InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。

**特点：**

- DML 操作遵循 ACID 模型，支持**事务**
- **行级锁**，提高并发访问性能
- 支持**外键**约束，保证数据的完整性和正确性

**文件：**

在`C:\ProgramData\MySQL\MySQL Server 5.5\data`下存放着InnoDB的表空间文件。每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。

* 参数innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间
* 查看表结构（cmd下）：`ibd2sdi xxx.ibd`

**逻辑存储结构:**

![1654433845981](/1654433845981.png)



**MyISAM**

MyISAM 是 MySQL 早期的默认存储引擎。

**特点：**

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

**文件：**

- xxx.sdi: 存储表结构信息
- xxx.MYD: 存储数据
- xxx.MYI: 存储索引



**Memory**

Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。

**特点：**

- 存放在内存中，速度快
- hash索引（默认）

**文件：**

- xxx.sdi: 存储表结构信息
- 数据存放在内存中



### 特点

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| **事务安全** | 支持                | -      | -      |
| **锁机制**   | 行锁                | 表锁   | 表锁   |
| B+tree索引   | 支持                | 支持   | 支持   |
| Hash索引     | -                   | -      | 支持   |
| 全文索引     | 支持（5.6版本之后） | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| **支持外键** | 支持                | -      | -      |



### 存储引擎的选择

在选择存储引擎时，应该根据应用系统的特点和需求选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择
- MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。
- Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性（被Redis替代）

电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。



---



# 索引

### 概念

索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。

**优点：**

- 提高数据检索效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

**缺点：**

- 索引列也是要占用空间的

- 索引虽然提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE

  >问题：索引是建立得越多越好吗？
  >
  >1. 数据量小的表不需要建立索引，建立会增加额外的索引开销
  >2. 对表中数据增删改时，需要动态维护索引，降低数据维护速度
  >3. 索引需要占物理空间，除了表数据占物理空间外，索引也需要存储
  >4. 如果写的比例远高于读，那么就没有必要创建索引。



**创建索引的两大步骤：**

1、提取每行记录中该字段的值，以该值当作key，至于key对的value，每种索引结构各不相同

2、然后以key值为基础构建索引结构



### 数据结构

##### 分类

MySQL索引主要使用的数据结构如下，按实现方式不同可以分为：

**HASH**

由于HASH的唯一及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找，因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，**当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引**，这样就让 B+Tree 索引具有哈希索引的一些优点 。

**BTREE+**

BTREE+索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（B+树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

**RTREE**

**RTREE**是用来做空间数据存储的树状数据结构。可以用来存储地图上的空间信息，例如餐馆地址。可以用它来回答“查找距离我2千米以内的博物馆”或者“查找（直线距离）最近的加油站”这类问题。

**FULLTEXT**

FULLTEXT：即为全文索引，只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引比 like + % 快 N 倍，但是可能存在精度问题；

**不同的存储引擎支持的索引类型：**

InnoDB存储引擎
 支持事务，支持行级别锁定，支持 B-tree（默认）、Full-text 等索引，不支持 Hash 索引；

MyISAM存储引擎
 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；

Memory存储引擎
 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；



##### BTREE

BTree是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。

一棵m阶B树，或为空树，或为满足下列特性对的m叉树：

* 树中每个结点最多含有m棵子树。

* 若根结点不是叶子结点，则至少有2个子树。

* 除根结点之外的所有非终端结点至少有⌈m/2⌉棵子树。（向上取整）

* 如果一个结点有n-1个关键字，则该结点有n个分支，且这n-1个关键字按照递增顺序排列。
  每个非终端结点中包含信息：（N，A0，K1，A1，K2，A2，...，KN，一）其中：

  * Ki（1≤i≤n）为关键字，且关键字按升序排序。

  * 指针Ai（0≤i≤n）指向子树的根结点，Ai-1指向子树中所有结点的关键字均小于Ki，且大于Ki-1;

  * 关键字的个数n必须满足：⌈m/2⌉-1≤n≤m-1。

  * 结点内关键字各不相等且按从小到大排列。


##### B+TREE

MyISAM和InnoDB底层都使用B+Tree进行存储。

**MyISAM**：

1. MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，同样使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
2. 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
3. MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录

**InnoDB**：

1. InnoDB的数据文件本身就是索引文件，这棵树的叶节点data域保存了完整的数据记录（聚集索引）
2. InnoDB的辅助索引data域存储相应记录主键的值而不是地址
3. 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

**为什么使用B+Tree:**

- Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
- 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
- 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。
- B+树：在B树的基础上，**B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**；此外将叶节点使用指针连接成链表，范围查询更加高效。B+树的**非叶子节点不保存数据**，只保存**子树的临界值**（最大或者最小），所以同样大小的节点。



### 聚集和非聚集索引

**分类：**

在MySQL中，B+树索引按照存储方式的不同可以分为聚集索引和非聚集索引。

**1、聚集索引（又称聚簇索引、主键索引，一张表必须有且只有一个）：**以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为innodb是把数据存放在B+树中的，而B+树的键用的就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。

**2、非聚集索引（又称非聚簇索引、辅助索引，一张表可以创建多个辅助索引）：**以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表操作。



**InnoDB聚集索引构建规则：**

- 有且只有一个聚集索引
- 若主键被定义，则主键作为聚集索引
- 如果没有主键被定义，该表的第一个唯一非空索引则作为聚集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（聚集索引）



**区别：**

- **（根本区别）表记录的排列顺序和索引的排序顺序是否一致；**

  > 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。

- 每张表只能有一个聚集索引，但可以有若干个非聚集索引；

- 聚集索引只需要查询一张表，而非聚集索引大部分情况都需要进行回表操作（当命中了某棵索引树，然后在其叶子节点刚好就找到了你想要的值，即不需要回表操作，这种情况被称为覆盖索引）；

- 聚集索引的叶节点存放的是数据，而非聚集索引的叶节点存放的是查询该数据对应的主键。



**缺点：**

* 聚集索引

  * 依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。

  * 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

* 非聚集索引

  * 依赖于有序的数据

  * 大概率需要二次查询(回表) ： 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。



### 联合索引

MySQL可以使用多个字段同时建立一个索引,叫做**联合索引**。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。



### 如何定位并优化慢查询SQL

首先介绍几个命令

`show variables like '%quer%'`：查看 相关的配置

![image-20210316231648801](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316231656.png)

> `long_query_time`：超过多少秒被看作为慢查询 10秒过长了 1秒比较合适
>
> `slow_query_log`：慢查询日志开启标志
>
> `slow_query_log_file`：慢查询日志的位置

`show status like '%slow_queries%'`：查看慢查询的数量

`set global slow_query_log = on`：打开慢查询

`set global long_query_time = 1`：设置慢查询的时间阈值为1秒（重新连接数据库再查询才会看到变化）

下面开始介绍调优

**1、打开慢日志（slow_query_log_file），慢日志中会存放慢SQL的语句**

![image-20210316233259613](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316233259.png)

**2、利用Explain对慢SQL语句进行分析**

**Explain**关键字段

> 常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看

1. id : 表示SQL执行的顺序的标识,SQL从大到小的执行

2. select_type：表示查询中每个select子句的类型

3. table：显示这一行的数据是关于哪张表的，有时不是真实的表名字

4. **type**（重要）：表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）如果是ALL(全表查找)或者index（索引的全表查找），需要优化

5. possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用

6. Key：key列显示MySQL实际决定使用的索引，如果没有选择索引，键是NULL。

7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）

8. ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

9. rows： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好

10. **extra**（重要）：该列包含MySQL解决查询的详细信息。

    如果`extra`列出现以下两项，则表示MYSQL根本不能使用索引，效率会受到重要影响，应尽可能对此进行优化。比如说filesort是在内存或者磁盘上进行排序了没走索引，可能是创建组合索引时没有按照条件顺序创建索引。temporary是在做表连结或者分组排序时，使用了临时表，解决问题可以通过group by和order by后的字段加索引这种方式，但是如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表。**若不能消除`Using temporary`临时表，那么需要在内联操作前，连接表尽可能小！**。还是得具体问题具体分析解决。

> mysql在遇到inner join连接语句时，mysql表关联的算法是`Nest Loop Join`(嵌套联接循环)。而`Nest Loop Join`就是通过两层循环手段进行依次的匹配操作。最后返回结果集合。在inner join中，**mysql会智能选择小表作为驱动表（基表）**，而另一张表叫做连接表。**首先会处理驱动表中没一行符合条件的数据，之后的每一行数据和连接表进行匹配操作，直至循环结束，最后合并结果返回给用户。**对于基表是可以使用索引来分组或者排序操作。而对于非驱动表的字段排序或者分组就会产生`using temporary`临时表。

![image-20210316234825572](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316234825.png)

3、改SQL语句用已有的索引进行查询，或者给要查询的字段名加上索引，尽量走索引

`alter table table_name add index idx_name(index_name)`

在我的项目中，我对大部分表的查询字段上都加上了索引，复杂的where条件查询的话给表加上了组合索引，同时也由于数据表不复杂，数据量小，我在慢查询日志里是没有慢查询记录的。然后我对几条使用频率很高的SQL语句做EXPLAIN分析后，也都保证查询的`type`是在`ref`这个等级以上的，extra中也没有`using filesort`以及`using temporary`这样的信息。

**联合索引的最左匹配原则**

1、对于联合索引，MySQL会一直向右匹配直到**遇到范围查询（>, <, between, like）就停止匹配**

例如：如果索引列分别为A，B，C，顺序也是A，B，C：

- 那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询
- 如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引
- 如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了
- 如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引（比如，a>= 3 and b = 4 and c = 5; A走索引，bc不走）（比如，a = 3 and b >= 4 and c = 5; a和b走，c不走）

2、=和in可以乱序，比如`a=1 and b = 2 and c=3`建立(a,b,c)索引可以任意顺序，MySQL查询优化器会帮助优化成索引可以识别的形式

成因

**组合索引的底层其实按照第一个索引排序，从排序里面再根据第二个索引排序，以此类推。  如果第一个索引失效，或者没有经过第一个索引，后面没法在前面的基础上查询。**







### 创建索引注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0，1，true，false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。









- ## Mysql索引会失效的几种情况分析

  1.如果条件中有or，即使其中有条件带索引也不会使用

  2.对于多列索引，不是使用的第一部分(第一个)，则不会使用索引

  3.like查询是以%开头

  4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

  5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引

## 锁

### Myisam和Innodb在锁上的区别

**MyISAM**：MyISAM只有表锁，其中又分为共享读锁和独占写锁。

- MyISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。
- MyISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。
- MyISAM表的读、写操作之间、以及写操作之间是串行的。

**Innodb**行锁：共享锁，排他锁

- 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X）；对于普通SELECT语句，Innodb不会加任何锁。

```
//显示共享锁（S） ：
 SELECT * FROM table_name WHERE .... LOCK IN SHARE MODE
 //显示排他锁（X）：
 SELECT * FROM table_name WHERE .... FOR UPDATE.
```

- 记录锁（Record Locks）：记录锁是封锁记录，记录锁也叫行锁，注意：行锁是针对索引的，如果表中没有索引，那么就会锁整张表
- 间隙锁（GAP）对于键值在条件范围内但并不存在的记录，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。
- 临键锁（Next-Key Lock）：（Record Locks+GAP），锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

MYISAM适合的场景：

- 频繁执行全表count语句（用一个变量保存的表的行数）
- 对数据进行增删改的频率不高，查询非常频繁（因为非聚集索引）
- 没有事务

InnoDB适合的场景

-  数据增删改查都相当频繁
-  可靠性要求比较高，要求支持事务 



### 并发事务带来的问题

**更新丢失、脏读、不可重复读和幻读**

**更新丢失**

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改**。例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。

**脏读**

第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100，此时第一个事务做了回滚。最终第二个事务读取的变量和数据库的不一样。

**不可重复读**

T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

**幻读**

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。（和不可重复读的区别：一个是变量变化，一个是范围变化，重点在insert上）

### 数据库的隔离级别

首先，介绍四种隔离级别

**未提交读（Read-Uncommitted）**

事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.**可能会导致脏读、幻读或不可重复读**

**已提交读（Read-Committed）**

对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；**可以阻止脏读，但是幻读或不可重复读仍有可能发生**

**可重复读（Repeatable-Read）**

就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；**可以阻止脏读和不可重复读，但幻读仍有可能发生**

**可串行读（Serializable）**

对每一句增删改查都加锁，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；**该级别可以防止脏读、不可重复读以及幻读**

**其次**，MySQL InnoDB 存储引擎的默认支持的隔离级别是 **Repeatable-Read**（可重读）

其次，**这里需要注意的是**：与 SQL 标准不同的地方在于InnoDB 存储引擎在 Repeatable-Read（可重读）事务隔离级别 下使用的是**Next-Key Lock 锁**算法，锁定记录本身并且锁定一个范围，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别（误，其实并没有完全解决）。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）并不会有任何性能损失**。

#### InnoDB在RR隔离级别下已经可以避免幻读，为什么还需要串行化隔离级别

马有失蹄：InnoDB尽管会通过加Gap锁避免在锁定的数据周围插入数据，但依然会存在幻读的情况

1. a事务先select（此时是MVCC快照读），b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意操作）
2. a事务再select出来的结果在MVCC下还和第一次select一样，
3. 接着a事务不加条件地update，这个update会作用在所有行上，包括b事务新加的，因为update意味着开启了当前读
4. a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了.

MySQL官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读，所以这个场景下，就算出现幻读了。

如果一定要完全避免幻读要么开启串行化隔离级别，要么就不使用快照读，直接在读的时候就开启当前读，给相应的段数据加锁，避免插入，也就类似于串行化了，但是串行化的性能很差，同时幻读很多时候是可以被接受的，所以没必要就不这么做。

### 快照读和当前读

![image-20210321233947959](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210321233955.png)

快照读（就是不加锁的非阻塞读，就是最普通的select操作）不能是 Serializable级别的select（退化了，都加锁了），快照读有可能在RR级别下读到历史版本，创建快照的时机（RR下建立事务后首次使用快照读的地方，RC下每次调用快照读都会创建一个新的快照）决定了读取数据的版本。

### 什么是MVCC

MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。

当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。

### RC和RR级别下的InnoDB非阻塞读如何实现

InnoDB使用了类似MVCC的方法实现非阻塞读。

首先数据行中会有`DB_TRX_ID`,`DB_ROLL_PTR`和`DB_ROW_ID`三个字段，分别代表事务ID，回滚指针，和行ID（类似于主键，在聚簇索引没有指定主键和索引时生成的隐藏主键）

当我们对记录做了变更操作时，就会产生undo log记录，undo记录中存储的是老版数据，当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着undo中以上的三个列找到满足其可见性的记录，这个找满足可见行的记录依赖 read view

read view主要是用来做可见性判断的，即当我们去执行快照读 select 的时候，会针对我们查询的数据创建出一个 read view，来决定当前事务能看到的是哪个版本的数据，有可能是当前最新版本的数据，也可能是 undo log 中某个版本的数据，read view 遵循一个可见性算法。

![image-20210322000407950](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210322000408.png)

快照读在RC、RR级别中：RR下，事务在第一个Read操作时，会建立Read View（读不到数据变更），所以看时机。
RC下，事务在每次Read操作时，都会建立Read View

Innodb当前读是通过加Next Key Lock（即record lock(记录锁)和gap lock(间隙锁)的结合）来实现的。 innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!

为什么是伪MVCC，是因为undo log中记录的是串行化的事务过程结果，不属于多版本共存。



### 读写分离原理 

主库（master）将sql操作写入**binlog**日志，然后从库（slave）连接到主库之后，从库有一个**IO线程**，将主库的binlog日志**拷贝到自己本地**，写入relay log中。接着从库中有一个SQL线程会从relay log中读取内容并执行，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。

这里有一个非常重要的一点，就是从库同步主库数据的过程是**串行化**的，也就是说**主库上并行**的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

所以mysql实际上在这一块有两个机制，一个是**半同步复制**，用来解决主库数据丢失问题；一个是**并行复制**，用来解决主从同步延时问题。

**半同步复制**：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，

**并行复制**：从库**开启多个线程，并行读取relay log中不同库的日志并执行**，本质是同时执行的SQL不存在锁争用。

### MVCC,redolog,undolog,binlog

- undoLog 也就是我们常说的**回滚日志文件** 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如"把id=‘B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =‘B’的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事务用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。
- redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。
- MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。
- binlog由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如"把id=‘B’ 修改为id = ‘B2’。binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。 产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复。

#### binlog和redolog的区别

1. redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。
2. 两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志。
3. 两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。
4. binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。
5. binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。

#### 二阶段提交

当数据写入时

一阶段是对redo log写，然后redo log进入prepare状态

二阶段是对binlog写，然后提交事务，redo log进入commit状态

这样的好处在于MySQL出现问题时，避免日志恢复的数据出现不一致的情况。

如果先写redolog，写完直接置为commit，然后再写binlog，在中间发生宕机时，系统利用redolog恢复的数据就会比binlog中记录的数据要多一条，出现数据不一致的情况。

如果先写binlog，再写redolog，如果写redo log时MySQL宕机了，那么binlog上的记录就会比磁盘上记录的数据多一条记录，在用binlog做恢复数据时或者主从同步时，就会导致主从之间数据不一致的情况。

利用二阶段提交可以避免这种情况。

## 解决哈希冲突的四种方法

1.开放地址方法：（1）线性探测  （2）再平方探测 （3）伪随机探测

2.链式地址法（HashMap的哈希冲突解决方法）

3.建立公共溢出区

4.再哈希法


