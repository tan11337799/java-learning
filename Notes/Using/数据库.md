---
typora-root-url: assets
typora-copy-images-to: assets
---



# MySQL基础

### 基础

**文件结构**

      		1. 安装目录
           * 配置文件 my.ini
    	2. MySQL数据目录：datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
  * 数据库：文件夹
  * 表：文件
  * 数据：数据



**语法**

* SQL语句可以单行j或多行书写，以分号结尾；
* 可以使用空格和缩进增强语句的可读性；
* MySQL 数据库的 SQL 语句不区分大小写，**关键字**建议使用大写。
* 3 种注释
    * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
   * 多行注释: /* 注释 */
   * SQL主要完成：C：Create	 R:Retrieve	 U:Update	 D:Delete



**数据类型**

整数类型：int

小数类型：float、double

日期类型：date(yyyy-MM-dd)、datatime(yyyy-MM-dd HH:mm:ss)、timestamp(yyyy-MM-dd HH:mm:ss，timestamp类型如果不给该字段赋值，或赋值为null，默认使用当前的系统时间自动赋值)

字符串类型：varchar



**分类**

* DDL(Data Definition Language)数据定义语言
  用来定义数据库对象：数据库，表，列等。**关键字：create, drop, alter**
* DML(Data Manipulation Language)数据操作语言
  用来对数据库中表的数据进行增删改。**关键字：insert, delete, update**
* DQL(Data Query Language)数据查询语言
  用来查询数据库中表的记录(数据)。**关键字：select, where**
* DCL(Data Control Language)数据控制语言(了解)
  用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等



### 安装

windows下较为简单不记录，下面主要介绍Linux下的安装。

**第一步**

将官网下载的MySQL安装包解压：

```shell
mkdir mysql
tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql
```

**第二步**

安装解压得到的rpm文件：

```bash
cd mysql
rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm 
rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm
yum install openssl-devel 
rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm
rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm
```

**第三步**

启动mysql服务：`systemctl start mysqld;`

**第四步**

查询自动生成的root用户密码 `grep 'temporary password' /var/log/mysqld.log`

用临时密码登陆mysqld：`mysql -u root -p`

**第五步**

修改root密码策略：

```bash
set global validate_password.policy = 0;
set global validate_password.length = 4;
```

修改密码（最低四位）：

`ALTER  USER  'root'@'localhost'  IDENTIFIED BY '1234';`

**第六步**

为远程访问创建用户：`create user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '1234';`

为root用户分配权限：`grant all on *.* to 'root'@'%';`

**第七步**

查看防火墙状态：`systemctl status firewalld.service`

开放防火墙3306端口：`firewall-cmd --zone=public --add-port=【portnum】/tcp --permanent`

重载防火墙配置（开放端口永久生效）：`firewall-cmd --reload`

在本地端连接该服务器



### 体系结构

MySQL 的架构共分为两层：**Server 层和存储引擎层**，

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

![1654418669796](/1654418669796.png)

结构：连接层-服务层-引擎层-存储层

![1654436740189](/1654436740189.png)



**连接层**

通过TCP三次握手启动MySQL服务，连接器负责验证用户名和密码。

如果用户名或密码不对，就收到一个"Access denied for user"的错误，然后客户端程序结束执行。

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。（所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置）

**问题1：空闲连接会一直占用着吗？**

MySQL 定义了空闲连接的最大空闲时长，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。

一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

**问题2：MySQL 的连接数有限制吗？**

MySQL 服务支持的最大连接数由 max_connections 参数控制，比如 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：

```
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。

**问题3：怎么解决长连接占用内存的问题？**

第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，客户端主动重置连接。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



**查询缓存**

连接器工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。

如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。

如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。所以，MySQL 8.0 版本直接将查询缓存删掉了。



**解析器**

在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由解析器来完成，解析器会做如下两件事情。

第一件事情，词法分析。MySQL 会根据输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

第二件事情，语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果我们输入的 SQL 语句语法不对，或者数据表或者字段不存在，都会在解析器这个阶段报错。



**查询优化器**

经过解析器后，接着就要执行 SQL 查询语句了，但是在真正执行之前，会检查用户是否有访问该数据库表的权限，如果没有就直接报错。

如果有权限，就进入 SQL 查询语句的执行阶段，而 SQL 查询语句真正执行之前需要先制定一个执行计划，这个工作交由「优化器」来完成的。

优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。



**执行器**

经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。



### 底层

**查询语句的过程**

- 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL 8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过分析器进行词法分析，提取 sql 语句的关键元素，比如 select，需要查询的表名，需要查询的列，以及查询条件。然后判断这个 sql 语句是否有语法错误，如果检查没问题就执行下一步。
- 接下来就是优化器进行确定执行方案，它会根据自己的优化算法进行选择它认为执行效率最好的一个方案。确认了执行计划后就准备开始执行了。
- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

**插入语句的过程**

- 先查询这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把数据更改好，然后调用存储引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 bin log，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成。



---



# MySQL基本操作

### 操作库和表（DDL）

##### 配置

**windows:**

打开服务：`net start mysql`

关闭服务：`net stop mysql`

连接mysql：`mysql -u[user] -p[password]`	（u和p后面为自己设置的账户密码）

连接mysql(隐私)：`mysql -u[user] -p`	（需要输入密码）

查看客户端连接情况：`show processlist`

远程连接mysql：`mysql -h[ip] -u[user] -p`

同上：`mysql –host=[ip] --user=[user] --password==[password]`

退出mysql：`exit` 或 `quit`

**linux:**

`systemctl start mysqld`   启动MYSQL服务

`systemctl restart mysqld`   重启MYSQL服务

`systemctl stop mysqld`   关闭MYSQL服务



##### **查询 SHOW**

查询数据库：

`show databases;`	查看所有的数据库名称

`select database();`	查询当前正在使用的数据库

`show create database 数据库名称;`	查询某个数据库的字符集（创建语句）

查询表：

`show tables;`	查看某个数据库中的所有表名称

`desc table1;`	查询表结构

`show create table 表名;`	查看建表语句



##### **创建 CREATE**

创建数据库：

`create database [if not exists] db1 [character set 字符集];`	创建数据集db1

创建表：

语法：

```mysql
create table t1(
	列1 数据类型1 [comment 注释1]，
	列2 数据类型2 [comment 注释2]，
	...
	列n 数据类型n [comment 注释n]
);# 最后一行不需要逗号
```

或使用复制来创建：`create table 复制表的表名 like 表名;`

数据类型创建格式：

- 整数： `age int;`
- 小数：`score double(5,2);`    小数最多五位，小数点后保留两位小数
- 日期：`birth date;`
- 字符串：`name varchar(20);`     规定最长的字符个数

举例：

```mysql
create table 表名(
	id int,
    name varchar(32),
    age int,
    score double(4,1),
    birthday date,
    insert_time timestamp
);
```



##### **修改 ALTER**

修改数据库：

`alter database db1 character set gbk;`	将数据库db1的字符集类型修改为gbk

修改表：

`alter table 表名 rename to 新表名;`	将表名重命名为新表名

`alter table 表名 character set utf8;`	修改表名的字符集为utf8

`alter table 表名 add 字段名 新数据类型;`	给指定表添加一个新字段

`alter table 表名 change 字段名 新字段名 新数据类型; `	修改字段名称和类型

`alter table 表名 modify 字段名 新数据类型;`	只修改字段的类型



##### **删除 DROP**

`drop database [if exists] db1;`	删除数据库db1

`drop table [if exsits] 表名;`	删除表



**其他**

`mysqldump -u用户名 -p密码 > 保存路径;`	备份当前的数据库

`source sql文件路径;`		还原数据库

`use db1;`	选择使用的数据库



---



### 操作数据（DML）

任务：增删改表中的数据。

##### **添加数据 INSERT**

语法：`insert into 表名(column1,column2,...) values(val1, val2, val3...);`

注意点：

* 字段名和值要一一对应；
* 如果表名后，不定义字段名`(c1,c2,…)`，则默认给所有字段添加值（必须保证val个数等于字段数）；



##### **删除数据 DELETE**

**语法：**`delete from 表名 [where 条件];`	在指定条件下删除数据

**举例：**`delete from stu where id=1;`		删除id=1的数据

**注意点：**

* 如果不加where条件，则删除表中的所有记录（不建议使用)；

* 我们一般使用`truncate table 表名;`删除表中的所有数据，truncate会删除表并创建一个一样的空表

  > truncate 与delete 比较： 
  >
  > truncate table 在功能上与不带 WHERE 子句的 delete语句相同：二者均删除表中的全部行。
  >
  > truncate 比 delete速度快，且使用的系统和事务日志资源少。
  >
  > 当表被清空后表和表的索引讲重新设置成初始大小，而delete则不能。



##### **修改数据  UPDATE**

**语法：**`update 表名 set column1=val1,column2=val2.... [where 条件];`

**举例：**`update stu set age=17,score=98 where id=1;`	修改id=1数据中age和score的值

**注意点：**

* 如果不加where条件，则会修改表中的所有记录（不建议使用）；



---



### 查询数据（DQL）

**语法：**

```mysql
select
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段
having
	分组之后的条件
order by
	排序
limit
	分页限定
```



##### 函数

**字符串函数**

| 函数                       | 功能                                                      |
| -------------------------- | --------------------------------------------------------- |
| CONCAT(s1, s2, …, sn)      | 字符串拼接，将s1, s2, …, sn拼接成一个字符串               |
| LOWER(str)                 | 将字符串全部转为小写                                      |
| UPPER(str)                 | 将字符串全部转为大写                                      |
| LPAD(str, n, pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
| RPAD(str, n, pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
| TRIM(str)                  | 去掉字符串头部和尾部的空格                                |
| SUBSTRING(str, start, len) | 返回从字符串str从start位置起的len个长度的字符串           |

使用示例：

```mysql
-- 拼接
SELECT CONCAT('Hello', 'World');
-- 小写
SELECT LOWER('Hello');
-- 大写
SELECT UPPER('Hello');
-- 左填充
SELECT LPAD('01', 5, '-');
-- 右填充
SELECT RPAD('01', 5, '-');
-- 去除空格
SELECT TRIM(' Hello World ');
-- 切片（起始索引为1）
SELECT SUBSTRING('Hello World', 1, 5);
```

**数值函数**

| 函数        | 功能                             |
| ----------- | -------------------------------- |
| CEIL(x)     | 向上取整                         |
| FLOOR(x)    | 向下取整                         |
| MOD(x, y)   | 返回x/y的模                      |
| RAND()      | 返回0~1内的随机数                |
| ROUND(x, y) | 求参数x的四舍五入值，保留y位小数 |

**日期函数**

| 函数                               | 功能                                              |
| ---------------------------------- | ------------------------------------------------- |
| CURDATE()                          | 返回当前日期                                      |
| CURTIME()                          | 返回当前时间                                      |
| NOW()                              | 返回当前日期和时间                                |
| YEAR(date)                         | 获取指定date的年份                                |
| MONTH(date)                        | 获取指定date的月份                                |
| DAY(date)                          | 获取指定date的日期                                |
| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
| DATEDIFF(date1, date2)             | 返回起始时间date1和结束时间date2之间的天数        |

例子：

```
-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);
```

**流程函数**

| 函数                                                         | 功能                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| IF(value, t, f)                                              | 如果value为true，则返回t，否则返回f                     |
| IFNULL(value1, value2)                                       | 如果value1不为空，返回value1，否则返回value2            |
| CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END      | 如果val1为true，返回res1，… 否则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END | 如果expr的值等于val1，返回res1，… 否则返回default默认值 |

**例子：**

```mysql
select name, (case when age > 30 then '中年' else '青年' end)from employee;
select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'from employee;
```





##### 基础查询

**查询多个字段**

`select 字段1,字段2,... from 表名;  `

注意点：我们可以使用*号替代整个字段列表

**去除重复**

`select distinct 字段列表 from 表名;`	

注意点：如果字段有多列，则只会去除每一列都相等的行

**计算列的表达式（四则运算）**

`select 字段1,字段2,expression(字段1,字段2) from 表名;`	

`select 字段1,字段2,expression(IFNULL(字段1,0)+IFNULL(字段2,0)) from 表名; `   避免NULL参与计算

注意点：（1）如果有NULL参与计算，则计算结果都为NULL；（2）mysql中可以使用ifnull返回相应结果：ifnull(c1,0)表示如果c1为null则用0替代

**起别名**

我们一般会给表起别名。

`select 字段1,字段2,expression(IFNULL(字段1,0)+IFNULL(字段2,0)) [as] 别名 from 表名;` 



**聚合函数**

将一列数据作为一个整体，进行**纵向**的计算。包括以下几种：

count: 计算个数

max: 计算最大值

min: 计算最小值

sum: 求和

avg: 计算平均值

**语法：**`SELECT 聚合函数(字段列表) FROM 表名;`

**例：**`SELECT count(id) from employee where workaddress = "广东省";`

**注意点：**

- 聚合函数会排除null值：（1）选择不包含非空的列（主键）进行计算；（2）我们使用IFNULL函数去除NULL；



##### 高级查询

**条件查询 WHERE**

**语法：**`SELECT 字段列表 FROM 表名 WHERE 条件列表;`

**运算符**

* `>,<,>=,<=,=,<>`     判断运算符（在mysql中使用<>表示不等于，也可以使用!=）
* `LIKE "%c%"`    模糊查询（最为常用）
* `IS (NOT) NULL`    空/非空判断（不能使用等号判断NULL）
* `IN(val1,val2,...)`   ()可以表示一个集合
* `BETWEEN…AND`    在一个范围内（包含边界）
* `and(&&),or(||),not(!)`    逻辑运算符

**举例**

```mysql
# 查询年龄不等于20的数据
SELECT * FROM student WHERE age!=20;
SELECT * FROM student WHERE age<>20;
# 查询年龄在20-30之间数据
SELECT * FROM student WHERE age>=20 AND age<30;
SELECT * FROM student WHERE age BETWEEN 20 AND 30;
# 查询年龄为22/19/25岁的信息
SELECT * FROM student WHERE age=22 OR age=19 OR age=25;
SELECT * FROM student WHERE age IN(22,19,25);
# 查询有/没有英语成绩的信息
# (语句错误，不能使用等号判断NULL)SELECT * FROM student WHERE english=NULL;
SELECT * FROM student WHERE english IS NULL;
SELECT * FROM student WHERE english IS NOT NULL;
# 模糊查询（常用）
SELECT * FROM student WHERE NAME LIKE "马%";    # 表示查询name为 马 开头的信息
SELECT * FROM student WHERE NAME LIKE "_化%";    # 表示查询第二个字为 化 的信息
SELECT * FROM student WHERE NAME LIKE "___";    # 表示查询name为三个字符的信息
SELECT * FROM student WHERE NAME LIKE "%马%";    # 表示查询name中包含 马 的信息
```



**排序查询 ORDER BY**

**语法：**`SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;`

* 当有多个排序条件时：`order by 排序字段1 排序方式1, 排序字段2 排序方式2…;`（只有前面的条件判断相同才判断后续条件）

**排序方式：**

* ASC：升序，默认
* DESC：降序

**具体：**

`select * from table order by 字段 (ASC);`    根据字段按升序排列（可将ASC省略）

`select * from table order by 字段 DESC;`    根据字段按降序排列

`select * from table order by 字段1 ASC/DESC, 字段2 ASC/DESC;`     按字段1排列，如果字段1相同则按字段2排列



**分组查询  GROUP BY**

**语法：**`SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];`

**注意点：**分组之后需要查询字段：**需要分组的字段**、**聚合函数**；加其他字段没有任何意义；

**限定条件：**

* `where 条件语句`    
  * 放在**group by之前**进行限定，如果不满足结果的**数据**则**不参加分组**；
  * where中不可以跟聚合函数
* `having 条件语句`    
  * 放在**group by之后**进行限定，如果不满足结果的**分组**则**不会被查询**；
  * having中可以进行聚合函数的判断

**举例：**

```mysql
SELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex;
SELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex HAVING COUNT(id)>2;	# 使用having限定，此时分组中会去除不满足条件的分组
SELECT sex,AVG(math),COUNT(id) FROM student WHERE math>70 GROUP BY sex;	# 使用where限定，此时select后的查询值只会计入符合where条件的数据
```



**分页查询 LIMIT**

**语法：**`SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; `

**公式：**`开始的索引=(当前页码-1)*每页显示的条数`

LIMIT分页是一种“方言”，在各类数据库中不同

**举例：**

```mysql
SELECT * FROM student LIMIT 0,3;# 第一页
SELECT * FROM student LIMIT 3,3;# 第二页
SELECT * FROM student LIMIT 6,3;# 第三页
```



---



### 用户管理（DCL）

DCL用于管理数据库用户，控制数据库的访问权限。这类操作SQL开发人员较少使用，主要是运维负责使用。

##### 管理

**查询用户：**

```mysql
USE mysql;
SELECT * FROM user;
```

**用户管理：**

```mysql
-- 添加用户
create user '用户名'@'主机名' identified by '密码';
-- 修改密码
update user set password=password('修改密码') where user='指定用户名';
-- ALTER  USER  'root'@'localhost'  IDENTIFIED BY '1234';
flush privileges; # 刷新权限，必须添加
-- 删除用户
DROP USER '用户名'@'主机名'; # 需要指定主机，否则只会删除任意主机的用户
```

**例子：**

```mysql
-- 创建用户test，只能在当前主机localhost访问
create user 'itcast'@'localhost' identified by '123456';
-- 创建用户test，能在任意主机访问
create user 'itcast'@'%' identified by '123456';
create user 'itcast' identified by '123456'; # 不添加指定主机默认为全部主机均可访问
-- 修改密码
update user set password=password('1234') where user='itcast';
flush privileges;# 刷新权限，必须添加
-- 删除用户
drop user 'itcast'@'localhost'; # 不添加指定主机会默认删除%的主机
```



##### **忘记密码**

* 关闭正在运行的MySQL服务。
* 打开DOS窗口，转到mysql\bin目录。输入`mysqld --skip-grant-tables`，启动MySQL服务的时候跳过权限表认证。
* 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），进入mysql。
* 连接权限数据库： `use mysql; `
* 修改密码：`update user set password=password(“root”) where user=“root”;`
  刷新权限（必须步骤）：`flush privileges;`　



##### 权限控制

**常用权限：**

| 权限                | 说明               |
| ------------------- | ------------------ |
| ALL, ALL PRIVILEGES | 所有权限           |
| SELECT              | 查询数据           |
| INSERT              | 插入数据           |
| UPDATE              | 修改数据           |
| DELETE              | 删除数据           |
| ALTER               | 修改表             |
| DROP                | 删除数据库/表/视图 |
| CREATE              | 创建数据库/表      |

更多权限请看[权限一览表](https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8)

**语法：**

`show grants;`	查询当前用户的权限

`SHOW GRANTS FOR '用户名'@'主机名';`	查询指定用户的权限

`GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';`    授予指定用户权限

`REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';`	撤销指定用户的权限



**注意事项：**

- 多个权限用逗号分隔
- 授权时，数据库名和表名可以用 * 进行通配，代表所有



---



# MySQL高级操作

### 数据库设计范式

**概念**

设计关系数据库时，需要遵从不同的规范要求，设计出合理的关系数据库。这些规范要求被称为**范式**，各类范式逐次规范，**越高的范式数据冗余度越小**。

**分类：**关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）、第五范式（5NF，完美范式）【一般满足前三范式即可基本满足数据库设计要求】

**名词解释：**

- **函数依赖：**通过A属性（属性组）的值，可以唯一确定B属性的值，称B依赖于A；【如：学号 => 姓名】
- **完全函数依赖：**如果A是一个属性组，则B属性值的确定需要依赖于A属性组中的所有属性值；【如：（学号，课程） => 分数】
- **部分函数依赖：**如果A是一个属性组，则B属性值的确定只需要依赖A属性组中的某一些值即可；【如：（学号，课程）=> 姓名】
- **传递函数依赖：**如果A属性（属性组），可以唯一确定B属性的值，再通过B属性（属性组）可以唯一确定C属性的值，则称C传递依赖于A；【如：学号=>系名=>系主任】
- **主关键字（码）：**如果一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的主关键字（码）；



**第一范式**

强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。



**第二范式**

在满足第一范式的基础上，要求非主属性完全依赖于主关键字（可能由多个属性组成）。

**目的：**在第一范式的基础上消除非主属性对主关键字的部分函数依赖，消除冗余。

**实现：**做表的拆分，直到每个表中每个非主属性都完全依赖于主关键字（不存在部分依赖于主关键字的属性）



**第三范式**

在满足第二范式的基础上，任何非主属性不依赖于其它非主属性。

**目的：**在第二范式的基础上消除传递依赖。

**实现：**做表的拆分，直到每个表的每个非主属性都不依赖于其他非主属性



### 约束

约束用于对表中的数据进行限定，保证数据的正确性、有效性和完整性。

**分类：**

- 主键约束：primary key
- 非空约束：not null
- 唯一约束：unique
- 外键约束：foreign key



##### **添加**

约束的添加一般有表创建时或创建表后两种方式设定

**语法：**

- 创建表时：

  ```mysql
  CREATE TABLE stu(
  	id INT PRIMARY KEY auto_increment, -- 设置id为主键并自动增长
  	NAME VARCHAR(20) NOT NULL,
      phone_number VARCHAR(20) UNIQUE
  );
  ```

- 创建表后：

  添加非空约束：`ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;`

  去除非空约束：`ALTER TABLE stu MODIFY NAME VARCHAR(20);`

  添加唯一约束：`ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;`

  去除唯一约束：`ALTER TABLE stu DROP INDEX phone_number;`

**注意点：**

- **非空约束**如果数据中需要设定的列本来有NULL则无法在创建表后设定；
- **唯一约束**允许数据出现NULL值，但不允许出现第二个NULL值；
- 给**主键约束**的列设置自动增长后，原本不可为NULL的值允许为NULL值；



##### 主键约束

**介绍**

主键是是数据表中记录的唯⼀标识。

**注意点：**

- 主键非空且唯一
- 一张表只能有一个字段为主键，被添加主键约束的字段被称为主键字段；

**语法：**`PRIMARY KEY / AUTO_INCREMENT`

- 创建表前：

  ```mysql
  CREATE TABLE stu(
  	id INT PRIMARY KEY auto_increment, -- 设置id为主键并自动增长
  );
  ```

- 创建表后：

  添加主键约束：`ALTER TABLE stu MODIFY id INT PRIMARY KEY;`

  去除主键约束：`ALTER TABLE stu DROP PRIMARY KEY;`

  添加自动增长：`ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;`

  去除自动增长：`ALTER TABLE stu MODIFY id INT;`



**自动增长**

**概念：**如果某一列数据是数值类型，可以使用自动增长完成值的自增

**注意点：**

- 自动增长一般用于主键，也可以用于非主键（较少）；
- 自动增长列数据的添加可以不设置，也可以设置为NULL（不管是不是主键）；
- 自增只会根据上一条记录的值+1，而不会记录真实的长度



##### 外键约束

**介绍**

外键约束是在父子表关系中体现的一种约束操作，其用于让表和表产生关系，从而保证数据的正确性。

**注意点：**

- 外键字段依赖于已经存在的表的一个主键，所以一定要先有主表
- 外键字段必须和主表的主键字段的数据类型要相似：如果是数值型，两者必须类型一致，并且同时为有无符号；如果是字符串型，两者的长度可以不同，但是类型必须相同。
- 如果子表的外键字段没有创建索引，但是当我们创建完外键之后，它会自动的添加索引。
- 如果子表中有记录外键关联着主表中的记录：（1）主表中的这条记录以及主表无法删除；（2）子表中的这些记录可以删除；（3）也不能在子表的外键中添加不是来自该主表列的记录

**语法：**

- 创建表时：

  ```mysql
  create table 子表名(
  	...
  	外键列,
  	constraint 外键名称【自己取名】 foreign key (外键列名称) references 主表名称(主表列名称【一般为主键】)
  );
  ```

- 创建表后：

  添加外键：` ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称); `

  删除外键：`ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;`

**举例：**

```mysql
-- 创建表时添加外键约束
CREATE TABLE department(
	id INT PRIMARY KEY,
	dep_name VARCHAR(20),
	dep_location VARCHAR(20)
);# 一定要先创建主表，才能给子表添加外键约束
CREATE TABLE employee(
	id INT PRIMARY KEY,
	NAME VARCHAR(20),
	dep_id INT,
	CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id)
);
-- 创建表后添加和删除外键约束
ALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;-- 删除外键
ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY(dep_id) REFERENCES department(id);-- 添加外键
```



**级联操作**

**语法：**`ON UPDATE CASCADE`

设置级联更新：`ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE;`

删除级联更新：`ALTER TABLE 子表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名称(主表列名称) ON DELETE CASCADE;`



### 多表查询

**多表关系：**

多表关系可以分为：一对一、一对多、多对多

- 一对一，如：人和身份证

  实现方式：在任意一方添加唯一外键，指向另一方的主键。（实际是多余操作）

- 一对多，如：部门与员工

  实现方式：在多的一方建立外键，指向一的一方的主键。

- 多对多，如：学生和课程

  实验方式：借助第三张中间表，中间表至少包含两个字段，分别指向两张表的主键。


**笛卡尔积：**

* 有两个集合A、B，取这两个集合的所有组成情况。
* 要完成多表查询，需要消除无用的数据

**多表查询正确方式：**

* 为了避免笛卡尔积， 可以在 WHERE 加入有效的连接条件；
* 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表；
* 可以给表起别名，在SELECT和WHERE中使用表的别名；

**分类**

* 表连接查询
  * 内连接
    * 隐式内连接
    * 显示内连接
  * 外连接
    * 左外连接
    * 右外连接
* 子查询



##### 内连接查询

**分类：**可以分为隐式内连接和显式内连接两种。

**注意点：**

* from后，哪张表在前面，哪个就是主体

**隐式内连接：**

* 特点：没有`JOIN`关键字，条件使用`WHERE`指定
* 语法：`select * from 表1,表2,… where 表1.prop=表2.prop;`
* 举例：

    ```mysql
    -- 查询所有员工信息和对应的部门信息
    SELECT * FROM dept,emp WHERE dept.`id`=emp.`dept_id`;
    -- 查询员工表的名称，性别。部门表的名称
    SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

    -- 起别名
    SELECT 
        t1.name, -- 员工表的姓名
        t1.gender,-- 员工表的性别
        t2.name -- 部门表的名称
    FROM
        emp t1,
        dept t2
    WHERE 
        t1.`dept_id` = t2.`id`;
    ```

**显式内连接：** 

* 特点：使用`INNER JOIN ... ON`语句, 可以省略`INNER`

* 语法：`select 字段列表 from 表名1 [inner] join 表名2 on 条件;`

* 举例：

    ```mysql
    SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	# INNER可加可不加
    SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	
    ```



##### **外连接查询**

**分类：**可以分为左外连接和右外连接两种。

**左外连接（常用）：**

* 特点：左外连接查询的是左表所有数据以及其交集部分。可以理解为：将满足要求的数据显示，左表不满足要求的数据也显示(在内连接的基础上,保证左表的数据全部显示)
* 语法：`select 字段列表 from 表1 left [outer] join 表2 on 条件;`
* 举例：
    ```mysql
    -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
    SELECT 	
        t1.*,t2.`name` 
    FROM 
        emp t1 LEFT JOIN dept t2 
    ON 
        t1.`dept_id` = t2.`id`;
    ```

**右外连接：**

* 特点：右外连接查询的是右表所有数据以及其交集部分。可以理解为：满足要求的数据显示,并且右表不满足要求的数据也显示(在内连接的基础上保证右边的数据全部显示)

* 语法：`select 字段列表 from 表1 right [outer] join 表2 on 条件;`

* 举例：

    ```mysql
    SELECT 	
        t1.*,t2.`name` 
    FROM 
        emp t1 RIGHT JOIN dept t2 
    ON 
        t1.`dept_id` = t2.`id`;
    ```



##### 自连接查询

当前表与自身的连接查询，自连接必须使用表别名

**语法：**`SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;`

自连接查询，可以是内连接查询，也可以是外连接查询

**例子：**

```mysql
-- 查询员工及其所属领导的名字
select a.name, b.name from employee a, employee b where a.manager = b.id;
-- 没有领导的也查询出来
select a.name, b.name from employee a left join employee b on a.manager = b.id;
```



##### 子查询

SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。
`SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);`

**举例：**

```mysql
-- 查询最高工资员工的信息
SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);
```

**子查询的不同情况：**

* 标量子查询（子查询的结果为单行单列）：

  子查询返回的结果是单个值（数字、字符串、日期等）。
  常用操作符：- < > > >= < <=子查询可以作为条件，使用运算符（大于小于等于）进行判断。

  举例：`select * from emp where emp.salary<(select AVG(salary) from emp);` 查询员工工资小于平均工资的员工

* 列子查询（子查询的结果是多行单列）：

  子查询可以作为条件，可以使用运算符in来判断（in是用于集合判断的关键字）

  需求：查询部门为财务部或市场部的员工

  `SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');` 

* 行子查询（子查询的结果是单行多列）：

* 表子查询（子查询的结果是多行多列）：

  需求：查询员工入职日期是2011.11.11之后的员工信息和部门信息

  ```mysql
  # 使用子查询
  SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2 WHERE t1.id = t2.dept_id;
  # 使用普通内连接（更好理解）
  SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11';
  ```


### 练习题

表的创建

```mysql
-- 部门表
CREATE TABLE dept (
  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
  dname VARCHAR(50), -- 部门名称
  loc VARCHAR(50) -- 部门所在地
);

-- 添加4个部门
INSERT INTO dept(id,dname,loc) VALUES 
(10,'教研部','北京'),
(20,'学工部','上海'),
(30,'销售部','广州'),
(40,'财务部','深圳');

-- 职务表，职务名称，职务描述
CREATE TABLE job (
  id INT PRIMARY KEY,
  jname VARCHAR(20),
  description VARCHAR(50)
);

-- 添加4个职务
INSERT INTO job (id, jname, description) VALUES
(1, '董事长', '管理整个公司，接单'),
(2, '经理', '管理部门员工'),
(3, '销售员', '向客人推销产品'),
(4, '文员', '使用办公软件');

-- 员工表
CREATE TABLE emp (
	id INT PRIMARY KEY, -- 员工id
	ename VARCHAR(50), -- 员工姓名
	job_id INT, -- 职务id
	mgr INT , -- 上级领导
	joindate DATE, -- 入职日期
	salary DECIMAL(7,2), -- 工资
	bonus DECIMAL(7,2), -- 奖金
	dept_id INT, -- 所在部门编号
	CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
	CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 添加员工
INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);

-- 工资等级表
CREATE TABLE salarygrade (
	grade INT PRIMARY KEY,   -- 级别
	losalary INT,  -- 最低工资
	hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
(1,7000,12000),
(2,12010,14000),
(3,14010,20000),
(4,20010,30000),
(5,30010,99990);

```

题目：

```mysql
-- 需求1：查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
SELECT 
	t1.`id`,t1.`ename`,t1.`salary`,t2.`jname`,t2.`description` 
FROM 
	emp t1,job t2 
WHERE 
	t1.`job_id`=t2.`id`;

-- 需求2：查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
SELECT 
	t1.`id`,t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`
FROM 
	emp t1,job t2,dept t3
WHERE 
	t1.`job_id`=t2.`id` AND t1.`dept_id`=t3.`id`;
	
-- 需求3：查询员工姓名、工资和工资等级
SELECT 
	t1.`ename`,t1.`salary`,t2.`grade`
FROM
	emp t1,salarygrade t2
WHERE
	t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
	
-- 需求4：查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
SELECT 
	t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`,t4.`grade`
FROM
	emp t1,job t2,dept t3,salarygrade t4
WHERE
	t1.`job_id`=t2.`id` AND t1.`dept_id`=t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;

-- 需求5：查询出部门编号、部门名称、部门位置、部门人数
SELECT 
	t1.`id`,t1.`dname`,t1.`loc`,t2.`total`
FROM
	dept t1,
	(
		SELECT 
			dept_id,COUNT(id) total
		FROM
			emp
		GROUP BY 
			dept_id
	) t2
WHERE
	t1.`id` = t2.dept_id;
	
-- 需求6：查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
SELECT
	t1.`id`,t1.`ename`,t2.`mgr`,t2.`ename`
FROM
	emp t1 LEFT JOIN emp t2

ON
	t1.`mgr` = t2.`id`;
```



---



### 事务

##### 概念

如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

**操作**

查看/设置事务提交方式：

```mysql
select @@autocommit;
set @@autocommit=0;# 0为关闭自动提交操作；1为打开自动提交操作
```

开启事务： `start transaction;`

回滚：`rollback;`

提交：`commit;`

**举例：**

```mysql
start transaction;  -- 开启事务
update account set money = money-1000 where name='张三';
qwe  -- 发生错误，此时事务不会继续执行，需要选择commit或rollback
update account set money = money+1000 where name='李四';
commit;
rollback;
```



##### 四大特征

**概念**

- 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败
- 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态
- 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的



**保证一致性**

- **从数据库层面**，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。**数据库必须要实现AID三大特性，才有可能实现一致性**。例如，原子性无法保证，显然一致性也无法保证。
- **从应用层面**，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

**保证原子性**

OK，是利用Innodb的**undo log**。 **undo log**名为回滚日志，是实现原子性的关键，他需要记录你要回滚的相应日志信息，当事务回滚时能够撤销所有已经成功执行的sql语句。 例如

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

**undo log**记录了这些回滚需要的信息，当事务执行失败或调用了**rollback**，导致事务需要回滚，便可以利用**undo log**中的信息将数据回滚到修改之前的样子。

**保证持久性**

利用Innodb的**redo log**。在更改数据时，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用**redo log**解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在**redo log**中记录这次操作。当事务提交的时候，会将**redo log**日志进行刷盘(**redo log**一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据**undo log**和**binlog**内容决定回滚数据还是提交数据。

**采用redo log的好处？**

其实好处就是将**redo log**进行刷盘比对数据页刷盘效率高，具体表现如下：

- **redo log**体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- **redo log**是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

**保证隔离性**

利用的是锁和MVCC机制。



##### 并发事务问题

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没提交的数据<br />（举例：第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100） |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同<br />（举例：T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同） |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是再insert数据时，又发现这行数据已经存在<br />（举例：T1 读取某个范围的数据，没有对应的数据行；T2 在这个范围内插入新的数据并提交；T1 插入数据时，发现此数据行已存在，进行查询却发现该数据不存在） |

>幻读和不可重复读的区别：不可重复读是由于另一个事务对数据的UPDATE和DELETE所造成的，而幻读是由于另一个事务INSERT数据引起的



##### 隔离级别

| 隔离级别              | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| Read uncommitted      | √    | √          | √    |
| Read committed        | ×    | √          | √    |
| Repeatable Read(默认) | ×    | ×          | √    |
| Serializable          | ×    | ×          | ×    |

- Serializable 性能最低，数据安全性最好；Read uncommitted 性能最高，数据安全性最差

- 可重复读是MySQL数据库的默认级别，而读已提交是其他数据库的常见默认级别。


**语法：**

查看事务隔离级别：`SELECT @@tx_isolation;`

设置事务隔离级别：`SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };`SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效



---



# 底层原理

### 存储引擎

##### 概念

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。

MySQL默认存储引擎是InnoDB。



**语法**

`CREATE TABLE 表名( 表内容 ) ENGINE=指定存储引擎;` 	创建表时选择存储引擎

`show engines;`	显示当前数据库文件支持的存储引擎



##### 三大引擎

**InnoDB**

InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。

**特点：**

- DML 操作遵循 ACID 模型，支持**事务**
- **行级锁**，提高并发访问性能
- 支持**外键**约束，保证数据的完整性和正确性

**文件：**

在`C:\ProgramData\MySQL\MySQL Server 5.5\data`下存放着InnoDB的表空间文件。每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。

* 参数innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间
* 查看表结构（cmd下）：`ibd2sdi xxx.ibd`

**逻辑存储结构:**

![1654433845981](/1654433845981.png)



**MyISAM**

MyISAM 是 MySQL 早期的默认存储引擎。

**特点：**

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

**文件：**

- xxx.sdi: 存储表结构信息
- xxx.MYD: 存储数据
- xxx.MYI: 存储索引



**Memory**

Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。

**特点：**

- 存放在内存中，速度快
- hash索引（默认）

**文件：**

- xxx.sdi: 存储表结构信息
- 数据存放在内存中



##### 特点

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| **事务安全** | 支持                | -      | -      |
| **锁机制**   | 行锁                | 表锁   | 表锁   |
| B+tree索引   | 支持                | 支持   | 支持   |
| Hash索引     | -                   | -      | 支持   |
| 全文索引     | 支持（5.6版本之后） | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| **支持外键** | 支持                | -      | -      |



##### 存储引擎的选择

在选择存储引擎时，应该根据应用系统的特点和需求选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择
- MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。
- Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性（被Redis替代）

电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。



---



### 索引

##### 概念

索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。

**优点：**

- 提高数据检索效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

**缺点：**

- 索引列也是要占用空间的

- 索引虽然提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE

  >问题：索引是建立得越多越好吗？
  >
  >1. 数据量小的表不需要建立索引，建立会增加额外的索引开销
  >2. 对表中数据增删改时，需要动态维护索引，降低数据维护速度
  >3. 索引需要占物理空间，除了表数据占物理空间外，索引也需要存储
  >4. 如果写的比例远高于读，那么就没有必要创建索引。



**创建索引的两大步骤：**

1、提取每行记录中该字段的值，以该值当作key，至于key对的value，每种索引结构各不相同

2、然后以key值为基础构建索引结构



##### 数据结构

MySQL索引主要使用的数据结构如下，按实现方式不同可以分为：

**HASH**

由于HASH的唯一及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找，因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，**当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引**，这样就让 B+Tree 索引具有哈希索引的一些优点 。

**BTREE+**

BTREE+索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（B+树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

**RTREE**

**RTREE**是用来做空间数据存储的树状数据结构。可以用来存储地图上的空间信息，例如餐馆地址。可以用它来回答“查找距离我2千米以内的博物馆”或者“查找（直线距离）最近的加油站”这类问题。

**FULLTEXT**

FULLTEXT：即为全文索引，只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引比 like + % 快 N 倍，但是可能存在精度问题；

**不同的存储引擎支持的索引类型：**

InnoDB存储引擎
 支持事务，支持行级别锁定，支持 B-tree（默认）、Full-text 等索引，不支持 Hash 索引；

MyISAM存储引擎
 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；

Memory存储引擎
 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；



##### BTREE

BTree是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。

一棵m阶B树，或为空树，或为满足下列特性对的m叉树：

* 树中每个结点最多含有m棵子树。

* 若根结点不是叶子结点，则至少有2个子树。

* 除根结点之外的所有非终端结点至少有⌈m/2⌉棵子树。（向上取整）

* 如果一个结点有n-1个关键字，则该结点有n个分支，且这n-1个关键字按照递增顺序排列。
  每个非终端结点中包含信息：（N，A0，K1，A1，K2，A2，...，KN，一）其中：

  * Ki（1≤i≤n）为关键字，且关键字按升序排序。

  * 指针Ai（0≤i≤n）指向子树的根结点，Ai-1指向子树中所有结点的关键字均小于Ki，且大于Ki-1;

  * 关键字的个数n必须满足：⌈m/2⌉-1≤n≤m-1。

  * 结点内关键字各不相等且按从小到大排列。


##### B+TREE

MyISAM和InnoDB底层都使用B+Tree进行存储。

**MyISAM**：

1. MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，同样使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
2. 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
3. MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录

**InnoDB**：

1. InnoDB的数据文件本身就是索引文件，这棵树的叶节点data域保存了完整的数据记录（聚集索引）
2. InnoDB的辅助索引data域存储相应记录主键的值而不是地址
3. 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

**为什么使用B+Tree:**

- Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
- 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
- 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。
- B+树：在B树的基础上，**B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**；此外将叶节点使用指针连接成链表，范围查询更加高效。B+树的**非叶子节点不保存数据**，只保存**子树的临界值**（最大或者最小），所以同样大小的节点。



##### 聚集和非聚集索引

**分类：**

在MySQL中，B+树索引按照存储方式的不同可以分为聚集索引和非聚集索引。

**1、聚集索引（又称聚簇索引、主键索引，一张表必须有且只有一个）：**以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为innodb是把数据存放在B+树中的，而B+树的键用的就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。

**2、非聚集索引（又称非聚簇索引、辅助索引，一张表可以创建多个辅助索引）：**以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表操作。



**InnoDB聚集索引构建规则：**

- 有且只有一个聚集索引
- 若主键被定义，则主键作为聚集索引
- 如果没有主键被定义，该表的第一个唯一非空索引则作为聚集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（聚集索引）



**区别：**

- **（根本区别）表记录的排列顺序和索引的排序顺序是否一致；**

  > 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。

- 每张表只能有一个聚集索引，但可以有若干个非聚集索引；

- 聚集索引只需要查询一张表，而非聚集索引大部分情况都需要进行回表操作（当命中了某棵索引树，然后在其叶子节点刚好就找到了你想要的值，即不需要回表操作，这种情况被称为覆盖索引）；

- 聚集索引的叶节点存放的是数据，而非聚集索引的叶节点存放的是查询该数据对应的主键。



**缺点：**

* 聚集索引

  * 依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。

  * 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

* 非聚集索引

  * 依赖于有序的数据

  * 大概率需要二次查询(回表) ： 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。



##### 联合索引

MySQL可以使用多个字段同时建立一个索引,叫做**联合索引**。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。



##### 如何定位并优化慢查询SQL

首先介绍几个命令

`show variables like '%quer%'`：查看 相关的配置

![image-20210316231648801](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316231656.png)

> `long_query_time`：超过多少秒被看作为慢查询 10秒过长了 1秒比较合适
>
> `slow_query_log`：慢查询日志开启标志
>
> `slow_query_log_file`：慢查询日志的位置

`show status like '%slow_queries%'`：查看慢查询的数量

`set global slow_query_log = on`：打开慢查询

`set global long_query_time = 1`：设置慢查询的时间阈值为1秒（重新连接数据库再查询才会看到变化）

下面开始介绍调优

**1、打开慢日志（slow_query_log_file），慢日志中会存放慢SQL的语句**

![image-20210316233259613](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316233259.png)

**2、利用Explain对慢SQL语句进行分析**

**Explain**关键字段

> 常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看

1. id : 表示SQL执行的顺序的标识,SQL从大到小的执行

2. select_type：表示查询中每个select子句的类型

3. table：显示这一行的数据是关于哪张表的，有时不是真实的表名字

4. **type**（重要）：表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）如果是ALL(全表查找)或者index（索引的全表查找），需要优化

5. possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用

6. Key：key列显示MySQL实际决定使用的索引，如果没有选择索引，键是NULL。

7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）

8. ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

9. rows： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好

10. **extra**（重要）：该列包含MySQL解决查询的详细信息。

    如果`extra`列出现以下两项，则表示MYSQL根本不能使用索引，效率会受到重要影响，应尽可能对此进行优化。比如说filesort是在内存或者磁盘上进行排序了没走索引，可能是创建组合索引时没有按照条件顺序创建索引。temporary是在做表连结或者分组排序时，使用了临时表，解决问题可以通过group by和order by后的字段加索引这种方式，但是如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表。**若不能消除`Using temporary`临时表，那么需要在内联操作前，连接表尽可能小！**。还是得具体问题具体分析解决。

> mysql在遇到inner join连接语句时，mysql表关联的算法是`Nest Loop Join`(嵌套联接循环)。而`Nest Loop Join`就是通过两层循环手段进行依次的匹配操作。最后返回结果集合。在inner join中，**mysql会智能选择小表作为驱动表（基表）**，而另一张表叫做连接表。**首先会处理驱动表中没一行符合条件的数据，之后的每一行数据和连接表进行匹配操作，直至循环结束，最后合并结果返回给用户。**对于基表是可以使用索引来分组或者排序操作。而对于非驱动表的字段排序或者分组就会产生`using temporary`临时表。

![image-20210316234825572](https://cdn.jsdelivr.net/gh/yanghao1550/MarkDownPics@master/pics/20210316234825.png)

3、改SQL语句用已有的索引进行查询，或者给要查询的字段名加上索引，尽量走索引

`alter table table_name add index idx_name(index_name)`

在我的项目中，我对大部分表的查询字段上都加上了索引，复杂的where条件查询的话给表加上了组合索引，同时也由于数据表不复杂，数据量小，我在慢查询日志里是没有慢查询记录的。然后我对几条使用频率很高的SQL语句做EXPLAIN分析后，也都保证查询的`type`是在`ref`这个等级以上的，extra中也没有`using filesort`以及`using temporary`这样的信息。

**联合索引的最左匹配原则**

1、对于联合索引，MySQL会一直向右匹配直到**遇到范围查询（>, <, between, like）就停止匹配**

例如：如果索引列分别为A，B，C，顺序也是A，B，C：

- 那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询
- 如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引
- 如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了
- 如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引（比如，a>= 3 and b = 4 and c = 5; A走索引，bc不走）（比如，a = 3 and b >= 4 and c = 5; a和b走，c不走）

2、=和in可以乱序，比如`a=1 and b = 2 and c=3`建立(a,b,c)索引可以任意顺序，MySQL查询优化器会帮助优化成索引可以识别的形式

成因

**组合索引的底层其实按照第一个索引排序，从排序里面再根据第二个索引排序，以此类推。  如果第一个索引失效，或者没有经过第一个索引，后面没法在前面的基础上查询。**







##### 创建索引注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0，1，true，false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。



---



# MyBatis框架

### 概述

**引出**

原始jdbc开发存在的问题如下：

1、 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能
2、sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。
3、查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置

应对上述问题给出的解决方案：

（1）使用数据库连接池初始化连接资源
（2）将sql语句抽取到xml配置文件中
（3）使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射



**特点**

*  mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。
* mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。
* 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。



### 快速入门

**（1）导入MyBatis坐标**

mybatis + mysql-connector-java

**（2）编写映射文件UserMapping.xml**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="fruitMapper">
    <select id="findAll" resultType="com.twhupup.entity.Fruit">
        select * from t_fruit
    </select>
</mapper>
```

映射文件的最外层标签为`<mapper>`，其属性namespace是命名空间，用于和语句的id一起组成访问的标识，进而调用指定的语句。（namespace.id）

需要执行的sql语句卸载mapper标签内。在这里`<select>`用于执行查询sql语句，其属性resultType用于将结果集封装到指定的结果类型中。



**（3）编写核心文件SqlMapConfig.xml**

```xml
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--配置数据源环境-->
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql:///fruit_db"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com/twhupup/mapper/FruitMapping.xml"/>
    </mappers>
</configuration>
```

核心文件的最外层标签是`<configuration>`，在该标签内配置数据源环境。environments中可以添加多个数据源，default表示默认使用environment的id。

`<mappers>`用于加载映射文件，将之前的映射文件添加到核心文件的配置中。

**（4）测试代码**

```java
//加载核心配置文件
InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
//获得sqlSession工厂对象
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
//获得sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession();
//执行sql语句
List<Fruit> fruitList = sqlSession.selectList("fruitMapper.findAll");
//打印结果
System.out.println(fruitList);
//释放资源
sqlSession.close();
```



**映射文件**

映射文件用于创建需要执行的语句和语句返回的类型

```xml
<mapper namespace="fruitMapper">
    <select id="findAll" resultType="com.twhupup.entity.Fruit">
        select * from t_fruit
    </select>
    <select id="findOne" resultType="com.twhupup.entity.Fruit" parameterType="int">
        select * from t_fruit where fid=#{abc}
    </select>
    <delete id="delete" parameterType="int">
        delete from t_fruit where fid=#{abc}
    </delete>
    <insert id="save" parameterType="com.twhupup.entity.Fruit">
        insert into t_fruit values(#{fid},#{fname},#{price},#{fcount},#{remark})
    </insert>
    <update id="update" parameterType="com.twhupup.entity.Fruit">
        update t_fruit set fname=#{fname},price=#{price},fcount=#{fcount},remark=#{remark} where fid=#{fid}
    </update>
</mapper>
```

![1656256240785](/1656256240785.png)

操作标签有resultType和parameterType两个属性，resultType用于指定查询导入的对象类型，parameterType用于指定传入单个参数的类型

**注意点：**

* 在sql的每个statement中，都存放需要执行的sql语句。语句中常用#{}和${}进行占位，对应parameterType的值。两者区别如下：
  * **#{}会在sql预编译之后再传入值。**在语句中表示一个占位符，可以有效防止sql注入，在使用时不需要考虑参数值的类型，mybatis会自动转换；另外如果paramterType只传入单个值，则该参数可以传入任意名称。
  * **${}会在编译之前，以拼接的方式加入到文件中。**可能会引起sql注入问题。不会对参数值类型进行自动转换。如果paramterType只传入单个值，则该参数的值必须和value的名称一致。



**核心配置文件**

**常用配置解析**

<img src="/image-20220627130922133.png" alt="image-20220627130922133" style="zoom:67%;" />

**（1）enviroments标签**

其中，事务管理器（transactionManager）类型有两种：

* JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。

* MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 
  应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置 
  为 false 来阻止它默认的关闭行为。

其中，数据源（dataSource）类型有三种：

* UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。
* POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。
* JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置 
  一个 JNDI 上下文的引用。

**（2）mapper标签**

该标签的作用是加载映射文件的，加载方式有如下几种：

* 使用相对于类路径的资源引用，例如：<mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
* 使用完全限定资源定位符（URL），例如：<mapper url="file:///var/mappers/AuthorMapper.xml"/>
* 使用映射器接口实现类的完全限定类名，例如：<mapper class="org.mybatis.builder.AuthorMapper"/>
* 将包内的映射器接口实现全部注册为映射器，例如：<package name="org.mybatis.builder"/>

**（3）Properties标签**

开发中习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件。进而在数据源配置的property标签中用${key}方式引入value值

```xml
<properties resource="jdbc.properties"></properties>
<environments default="developement">
    <environment id="developement">
        <transactionManager type="JDBC"></transactionManager>
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.driver}"/>
            <property name="url" value="${jdbc.url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="${jdbc.password}"/>
        </dataSource>
    </environment>
</environments>
```

**（4）typeAliases标签**

typeAliases标签用于设置别名，也就是为Java 类型设置一个短的名字。

以下代码用fruit作为别名代替Fruit类：

```xml
<typeAliases>
    <typeAlias type="com.twhupup.entity.Fruit" alias="fruit"></typeAlias>
</typeAliases>
```

在查询语句中使用别名：

```xml
<select resultType="fruit">
    select * from t_fruit
</select>
```

mybatis框架为我们预设了一些别名：

<img src="/image-20220627132036863.png" alt="image-20220627132036863" style="zoom:67%;" />





### MyBatisAPI

**获取SqlSession**

```java
//通过加载mybatis核心文件的输入流形式构建SqlSessionFactory对象
InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");//输入核心配置类地址
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
//通过SqlSession工厂，获取sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession();
```

解析：

（1）Resources 类用于从类路径下、文件系统或一个 web URL 中加载资源文件，并返回一个输入流对象。

（2）`SqlSessionFactoryBuilder`是一个工厂构建器，用于获取一个工厂。

其主要方法是：`SqlSessionFactory build(InputStream inputStream)`，用于生成SqlSessionFactory。

（3）SqlSessionFactory 有多个方法创建 SqlSession 实例。

<img src="/image-20220627132502696.png" alt="image-20220627132502696" style="zoom:67%;" />



**查询多条数据**

语法：`<E> List<E> selectList(String statement, Object parameter)`

e.g.

```
List<Fruit> fruitList = sqlSession.selectList("fruitMapper.findAll");
```

**查询单条数据**

语法：`<T> T selectOne(String statement, Object parameter)`

e.g.

```
List<Fruit> fruitList = sqlSession.selectList("fruitMapper.findAll");
```

**添加数据**

将对象的值作为输入添加到数据库中

语法：`int insert(String statement, Object parameter)` 	返回值表示是否执行成功

e.g.

```
sqlSession.insert("fruitMapper.save",fruit);
```

**删除数据**

语法：`int delete(String statement, Object parameter)` 	返回值表示是否执行成功

e.g.

```
sqlSession.delete("fruitMapper.delete",11);
```

**修改数据**

语法：`int update(String statement, Object parameter) ` 	返回值表示是否执行成功

e.g.

```
sqlSession.update("fruitMapper.update",fruit);
```

**提交、回滚和关闭**

```java
//mybatis执行提交事务
sqlSession.commit();
//mybatis执行回滚事务
sqlSession.rollback();
//释放资源
sqlSession.close();
```

由于我们选择开启事务关闭自动提交，因此需要手动提交事务或回滚。



### 代理开发

采用Mybatis的**代理开发方式**实现  DAO 层的开发，这种方式是我们后面进入企业的主流。

Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同传统Dao接口实现类方法。

**Mapper 接口开发需要遵循以下规范：**

* Mapper.xml文件中的namespace与mapper接口的**全限定名**相同
* Mapper接口中的方法名和Mapper.xml中定义的每个statement的id相同
* Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同
* Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同

<img src="/image-20220627140833676.png" alt="image-20220627140833676" style="zoom:67%;" />

映射文件中：

```xml
<mapper namespace="com.twhupup.dao.FruitMapper">
    <select id="findAll" resultType="fruit">
        select * from t_fruit
    </select>
    <select id="findOne" resultType="fruit" parameterType="int">
        select * from t_fruit where fid=#{abc}
    </select>
 </mapper>
```

Mapper接口：

```java
public interface FruitMapper {
    public List<Fruit> findAll() throws IOException;
    public Fruit findOne(int fid);
}
```

操作代码中：

```java
@Test
public void testSelectOne() throws IOException {
   InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
   SqlSession sqlSession = sqlSessionFactory.openSession();
   FruitMapper mapper = sqlSession.getMapper(FruitMapper.class);//mapper对象的运行类型是FruitMapper类型的实现
   Fruit one = mapper.findOne(5);
   System.out.println(one);
}
```



### 底层原理

##### 接口映射原理

（1）通常我们使用 Mybatis 的主要步骤是：

* 构建 SqlSessionFactory ( 通过 xml 配置文件 , 或者直接编写Java代码)

* 从 SqlSessionFactory 中获取sqlSession

* 从sqlSession 中获取Mapper，例如BlogMapper（通过getMapper方法获取mapper的实现类）

* 调用 Mapper 的方法，例如：blogMapper.selectBlog(int blogId)

  ```java
  InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");//输入核心配置类地址
  SqlSessionFactory sqlSessionFactory = new  SqlSessionFactoryBuilder().build(inputStream);
  //通过SqlSession工厂，获取sqlSession对象
  SqlSession sqlSession = sqlSessionFactory.openSession(true);
  mapper = sqlSession.getMapper(UserMapper.class);
  ```

（2）在XMLMapperBuilder类下，有方法bindMapperForNamespace，该方法在解析mybatis的映射文件时，会根据mapper标签的namespace属性值，判断classpath下有没有这样一个接口的全路径与namespace属性值完全相同，如果有，则建立二者之间的映射关系。通过反射将以namespace为路径获取Mapper接口的Class对象。

![1656919588717](/1656919588717.png)

（3）将该mapper添加到Configuration类。并执行addMapper方法。在addMapper中，可以发现Mapper接口是放在哈希表中的，Key为当前Class对象，value为一个MapperProxyFactory 实例。

> Configuration类将addMapper和getMapper委派给了MapperRegistry来执行：
>
> * addMapper方法会针对这个Mapper接口生成一个MapperProxyFactory工厂类。
> * getMapper方法通过MapperProxyFactory工厂类，返回一个Mapper接口的动态代理类。

![1656920342725](/1656920342725.png)

（4）在使用该mapper时，通过调用session.getMapper(mapper.class)，通过debug可以发现方法先是调用了configuration的getMapper方法，最终是调用了MapperRegistry的getMapper方法。

getMapper方法以mapper的class对象为key，找到了对应的value，也就是mapperProxyFactory对象，然后调用这个对象的newInstance()方法生成mapper的代理对象MapperProxy。

![1656920497958](/1656920497958.png)

（5）接下来通过动态代理实现Mapper接口的CRUD功能。



### 动态sql

Mybatis 的映射文件中，前面我们的  SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的  SQL是动态变化的， 此时在前面的学习中我们的  SQL 就不能满足要求了。

**官网描述：**

<img src="/image-20220627151123420.png" alt="image-20220627151123420" style="zoom: 80%;" />

**特有元素：**

* if：条件判断
* foreach：循环
* choose
* trim



**（1）if标签**

我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在id如果不为空时可以根据id查询，如果
username 不同空时还要加入用户名作为条件。这种情况在多条件组合查询中很常见。

```xml
<select id="findByCondition" parameterType="fruit" resultType="fruit">
    select * from t_fruit
    <where>
        <if test="fid!=0">
            and fid=#{fid}
        </if>
        <if test="fname!=null">
            and fname=#{fname}
        </if>
        <if test="fcount!=0">
            and fcount=#{fcount}
        </if>
        <if test="price!=0">
            and price=#{price}
        </if>
    </where>
</select>
```

**（2）for-each标签**

用于对集合中的元素进行遍历，进而表示为sql语句形式

```xml
<select id="findByIds" parameterType="list" resultType="fruit">
    select * from t_fruit
    <where>
        <foreach collection="list" open="fid in(" close=")" item="id" separator=",">
            #{id}
        </foreach>
    </where>
</select>
```

foreach标签的属性含义如下：<foreach>标签用于遍历集合，它的属性：

* collection：代表要遍历的集合元素，注意编写时不要写#{}
* open：代表语句的开始部分
* close：代表结束部分
* item：代表遍历集合的每个元素，生成的变量名
* sperator：代表分隔符



### 核心配置文件

##### 文件层级关系

<img src="/image-20220627130812195.png" alt="image-20220627130812195" style="zoom:67%;" />

##### TypeHandler

无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。

我们可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。

**实现：**实现org.apache.ibatis.type.TypeHandler 接口， 或继承类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。

**例如**

需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。

**开发步骤：**
（1）定义转换类继承类`BaseTypeHandler<T>`

（2） 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时，mysql的字符串类型转换成java的Type类型的方法

（3）在MyBatis核心配置文件中进行注册

（4）测试转换是否正确

e.g.

(1) 转换类

```java
public class DataTypeHandler extends BaseTypeHandler<Date> {
    //负责将java类型转换为数据库需要的类型
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException {
        long time = date.getTime();
        preparedStatement.setLong(i,time);
    }

    //将数据库类型转换为java类型
    //String s表示要转换的字段名称,ResultSet表示查询出的数据集
    @Override
    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException {
        long aLong = resultSet.getLong(s);
        return new Date(aLong);
    }

    //将数据库类型转换为java类型
    @Override
    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException {
        long aLong = resultSet.getLong(i);
        return new Date(aLong);
    }

    //将数据库类型转换为java类型
    @Override
    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
        long aLong = callableStatement.getLong(i);
        return new Date(aLong);
    }
}
```

(2) 核心文件进行配置

```xml
<!--注册类型处理器-->
<typeHandlers>
	<typeHandler handler="com.twhupup.handler.DataTypeHandler"/>
</typeHandlers>
```



##### Plugins

在项目的pom.xml文件中引入相关包的坐标后，在核心配置文件中进行配置：

```xml
<plugins>
    <plugin interceptor="com.github.pagehelper.PageHelper">
        <property name="dialect" value="mysql"/>
    </plugin>
</plugins>
```



### 多表操作

##### ResultMap

ResultMap 是 Mybatis 最强大的元素之一，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。

resultMap 元素用来描述如何将结果集映射到 Java 对象，使用 resultMap 对列表展示所需的必要字段来进行自动映射，特别是当数据库的字段名和实体类 POJO 中的属性名不一致的情况下，比如角色名称，字段名/列名 column 是 roleName，而 User 对象的属性名则为 userRoleName ，此时就需要做映射。

**属性：**

- id：用于标明ResultMap映射的id，便于在后续标签语句中使用
- type：指定需要映射的类
- column：查询结果表的字段名
- property：实体类的属性名


**子节点：**用于映射type指定对象的每个属性。子节点有若干属性（id/result/association/collection）：

* ```xml
  <id column="oid" property="id"/>
  <result column="ordertime" property="ordertime"/>
  <result column="total" property="total"/>
  <association property="user" javaType="user">
      <id column="uid" property="id"/>
      <result column="username" property="username"/>
      <result column="password" property="password"/>
      <result column="birthday" property="birthday"/>
  </association>
  <!--另一个mapper-->
  <collection property="orderList" ofType="order">
      <id column="oid" property="id"/>
      <result column="ordertime" property="ordertime"/>
      <result column="total" property="total"/>
  </collection>
  ```

id和result都可以将查询到的列名映射到属性和简单的数字类型。两者的区别在于id可以作为结果集的标识属性，可以提高查询的效率。

association是对外部类的映射，在javaType中指定需要引用的外部类，这样每个property可以绑定到该对象中。

collection属性用于一对多查询，可以将查询到多条内容赋值给实体类列表，property表示该列表（多的一方）的属性名，ofType表示列表存储的对象类型。

**resultMap和resultType的区别：**

* 两者均用于查询语句中，当我们需要映射时只能使用其中一种。
* resultType表示直接的返回类型（不需要自己指定其中的某个属性，由MyBatis自动进行赋值），resultMap则可以存在对外部类的引用（用于多表查询）
* resultType要保证结果集的列名和对象的属性名一致，而resultMap不用；



##### 实现

**一对一查询**

一个order对应一个user

```xml
<mapper namespace="com.twhupup.dao.OrderMapper">
    <resultMap id="orderMap" type="order">
        <!--手动指定字段和实体属性的映射关系
            column:数据表的字段名称
            property:实体的属性名称
        -->
        <id column="oid" property="id"/>
        <result column="ordertime" property="ordertime"/>
        <result column="total" property="total"/>
        <association property="user" javaType="user">
            <id column="uid" property="id"/>
            <result column="username" property="username"/>
            <result column="password" property="password"/>
            <result column="birthday" property="birthday"/>
        </association>
    </resultMap>

    <select id="selectAll" resultMap="orderMap">
        select *,o.id oid from orders o,user u where o.uid=u.id
    </select>
</mapper>
```

**一对多查询**

一个user对应多个order

```xml
<mapper namespace="com.twhupup.dao.UserMapper">
    <resultMap id="userMap" type="user">
        <!--手动指定字段和实体属性的映射关系
            column:数据表的字段名称
            property:实体的属性名称
        -->
        <id column="uid" property="id"></id>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
        <collection property="orderList" ofType="order">
            <!--封装order的数据-->
            <id column="oid" property="id"></id>
            <result column="ordertime" property="ordertime"></result>
            <result column="total" property="total"></result>
        </collection>
    </resultMap>
    <select id="selectAll" resultMap="userMap">
        select *,o.id oid from user u,orders o where u.id=o.uid;
    </select>
</mapper>
```

**多对多查询**

```xml
<mapper namespace="com.twhupup.dao.UserMapper">
    <resultMap id="userRoleMap" type="user">
        <!--user的信息-->
        <id column="userId" property="id"></id>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
        <!--user内部的roleList信息-->
        <collection property="roleList" ofType="role">
            <id column="roleId" property="id"></id>
            <result column="roleName" property="roleName"></result>
            <result column="roleDesc" property="roleDesc"></result>
        </collection>
    </resultMap>

    <select id="findUserAndRoleAll" resultMap="userRoleMap">
        SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id
    </select>
</mapper>
```



### 注解开发

##### 增删改查

主要包括：

@Insert：实现新增

@Update：实现更新

@Delete：实现删除

@Select：实现查询

（1）在核心配置类添加映射类/包的路径

```xml
<mappers>
    <!--扫描使用注解的类-->
    <mapper class="com.twhupup.mapper.UserMapper"></mapper>
</mappers>
```

或者指定扫描包含映射关系的接口所在的包（不再需要映射文件）

```xml
<mappers>
    <!--扫描使用注解的类所在的包-->
    <package name="com.twhupup.mapper"></package>
</mappers>
```

（2）在映射类中添加注解

```java
public interface  UserMapper {
    @Insert("insert into user values(#{id},#{username},#{password},#{birthday})")
    public void save(User user);
    
    @Update("update user set username=#{username},password=#{password},birthday=#{birthday} where id=#{id}")
    public void update(User user);
    
    @Delete("delete from user where id=#{id}")
    public void delete(int id);
    
    @Select("select * from user where id=#{id}")
    public User findById(int id);
    
    @Select("select * from user")
    public List<User> findAll();
}
```

（3）测试中使用

定义公共部分，用@Before注释

```java
@Before
public void before() throws IOException {
    InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");//输入核心配置类地址
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    //通过SqlSession工厂，获取sqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession(true);
    mapper = sqlSession.getMapper(UserMapper.class);
}
```

直接使用

```java
@Test
public void testSave(){
    User user = new User();
    user.setUsername("tom");
    user.setPassword("abc");
    mapper.save(user);
}

@Test
public void testUpdate(){
    User user = new User();
    user.setId(10);
    user.setUsername("tom");
    user.setPassword("abd");
    mapper.update(user);
}
```



##### 复杂映射开发

@Result：实现结果集封装

@Results：可以与@Result 一起使用，封装多个结果集

@One：实现一对一结果集封装

@Many：实现一对多结果集封装



**@Result**

代替了`<id>`标签和`<result>`标签。

属性：

* id：选择true或false，表示该属性是否为id
* column：数据库的列名
* property：需要装配的属性名
* one：需要使用的@One 注解（@Result（one=@One）（）））
* many：需要使用的@Many 注解（@Result（many=@many）（）））



**@Results**

@Results 代替的是标签`<resultMap>`。

该注解中可以使用单个@Result注解，也可以使用@Result集
合。

使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（））



**@One**

用于一对一的多表查询，代替标签`<association>`。一般用于@Result中的one标签。

格式：（@Result内）`one=@One(select = classpath)`



**@Many**

用于一对多的多表查询，代替标签`<collection>`。一般用于@Result中的many标签。

格式：（@Result内）`many=@Many(select = classpath)`



**一对一查询实例：**

（一个订单对应一个用户）

```java
//先在UserMapper定义 findById
@Select("select * from user where id=#{id}")
public User findById(int id);

//在OrderMapper定义查询
@Select("select * from orders")
@Results({
    @Result(column = "oid", property = "id"),
    @Result(column = "ordertime", property = "ordertime"),
    @Result(column = "total", property = "total"),
    @Result(
        property = "user", //要封装的属性名称
        column = "uid", //根据哪个字段查询
        javaType = User.class, //封装的实体类
        one = @One(select = "com.twhupup.mapper.UserMapper.findById"))//查询某个接口的方法获取数据
})
public List<Order> findAll();
```

分析：在这里@One的作用就是将UserMapper中事先定义的查询内容作用于当前语句中，使得语句变成：`select * from user where id=...` ，这里的…则与findById查询的结果匹配。



**一对多查询实例：**

（一个用户对应多个订单）

```java
//先在OrderMapper定义 findByUid
@Select("select * from orders where uid=#{uid}")
public Order findByUid(int uid);

//在UserMapper定义查询
@Select("select * from user")
@Results({
    @Result(id = true, column = "id", property = "id"),
    @Result(column = "username", property = "username"),
    @Result(column = "password", property = "password"),
    @Result(
        property = "orderList",
        column = "id",
        javaType = List.class,
        many = @Many(select = "com.twhupup.mapper.OrderMapper.findByUid")
    )
})
public List<User> findUserAndOrderAll();
```

分析：在这里@Many的作用就是将OrderMapper中事先定义的查询内容作用于当前语句中，

使得语句变成：`select * from user where uid=...`，这里的…则与查询的结果和findByUid对应的结果匹配。



**多对多查询实例：**

（一个用户对应一张角色表sys_user_role对应角色sys_role）

```java
//先在RoleMapper定义 findByUid
@Select("SELECT * FROM sys_user_role ur,sys_role r WHERE ur.roleId=r.id AND ur.userId=#{uid}")
public List<Role> findByUid(int uid);

//在UserMapper定义查询
@Select("SELECT * FROM USER")
@Results({
    @Result(id = true,column = "id",property = "id"),
    @Result(column = "username",property = "username"),
    @Result(column = "password",property = "password"),
    @Result(
        property = "roleList",
        column = "id",
        javaType = List.class,
        many = @Many(select = "com.itheima.mapper.RoleMapper.findByUid")
    )
})
public List<User> findUserAndRoleAll();
```

分析：原理同上。



# MyBatis-plus框架

### 概述

**mybatis的实现**

- 编写实体类
- 创建mapper接口。在mapper接口中定义方法并且通过注解的方式绑定增删改查或者通过方面名绑定xml文件中的sql语句进行增删改查
- 在测试类调用方法或者在service层调用方法

**mybatis的优缺点**

优势：

* SQL语句可以自由控制，更灵活、性能较高。
* SQL与代码分离，易于阅读和维护。
* 提供XML标签，支持编写动态SQL语句。

劣势：

* 简单CRUD操作需要编写SQL语句（单表仍需要编写Mapper接口方法和xml的sql）
* XML中有大量sql需维护
* mybatis自身功能有限

**Mybatis-plus介绍**

mybatis-plus简称**MP**，是一款Mybatis增强工具，只做增强，不作改变，简化开发，提高效率。

MP在mybatis启动的时候，它在mybatis的xml和注解注入之后，紧接着反射分析实体，然后注入到底层容器中。注入之前MP会进行判断，是否已经注入同样的方法，如果已经注入，就不在注入。它的注入时机在容器启动时，所以MP使用crud、本身是无性能损耗的。

**Mybatis-plus特点**

1、无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性

2、依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring

3、损耗小：启动即会自动注入基本CRUD，性能基本无损耗，直接面向对象操作

4、通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求

5、多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题

6、支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作

7、支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！）
支持自定义全局通用操作：支持全局通用方法注入( Write once, use anywhere )

8、内置分页插件：基于Mybatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于写基本List查询

9、内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询

10、内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作



### 原理

#### 雪花算法

MP的默认主键策略是基于雪花算法的自增主键，因此不需要对主键进行自增配置。

SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的，后面的代码中有详细的注解。

注意点：

- 主键采用雪花算法生成值的前提是实体类的主键属性名称必须为id；



### lombok

lombok是一个作用于编辑器和构建工具的 Java 库，可以对编写的 Java 代码进行增强，比如说不用再写实体类的 getter 方法，equals 方法而是自动生成，自动生成日志输出变量等等，减少重复模板的代码。

**主要注解：**

**@Data/@Value**

该注解为lombok的常用注解，用于自动生成实体类的方法。

该注解用于实体类上，为实体类自动添加getter、setter方法，有参构造器方法，equals方法，hashcode方法，toString方法。

```java
//该注解包含以下几个注解：
@Getter
@Setter
@AllArgsConstructor
@EqualsAndHashCode
@ToString
```

**各子注解分析：**

* `@Getter/@Setter` 为实体类提供 getter 和 setter 方法

* `@ToString` 为实体类添加易阅读的 toString 方法，带上有所非静态字段的属性名称和值，便于我们日常开发时进行的打印操作。

  可以使用属性 @ToString.Exclude排除不需要在 toString 中出现的字段，使用 @ToString.Include标记需要出现在 toString 中的字段

* `@NoArgsConstructor` 为实体类生成无参的构造器方法

  `@AllArgsConstructor` 为实体类生成除了static修饰的字段之外带有各参数的构造器方法。

  `@RequiredArgsConstructor `为实体类生成指定字段的构造器方法，而这些字段需要被 final，或者 @NonNull修饰。

* `@EqualsAndHashCode` 用于根据类所拥有的非静态字段自动重写equals方法和 hashCode 方法,方便我们用于对象间的比较。



**其他注解：**

* `@NonNull`

  @NonNull 用于标记类中不能允许为 null 的字段或者参数上，任何使用该字段的地方都生成空指针判断代码，若@NonNull 标记的变量为 null，抛出 NullPointException （NPE） 异常。

    ```java
    public LombokEntity(@NonNull String value) {
        this.value = value;
    }
    ```

* `@Builder`

  @Builder 是一个非常强大的注解，提供了一种基于建造者模式的构建对象的 API。使用 @Builder 注解为给我们的实体类自动生成 builder() 方法，并且直接根据字段名称方法进行字段赋值，最后使用 build()方法构建出一个实体对象。



**日志相关注解：**

* `@CommonsLog` 

  等价效果： private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);

* `@Flogger` 

  等价效果： private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();

* `@JBosLog`

  等价效果： private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);

* `@Log` 

  等价效果： private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());

* `@Log4j` 

  等价效果： private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);

* `@Log4j2` 

  等价效果： private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);

* `@Slf4`j 

  等价效果： private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);

* `@XSlf4j` 

  等价效果: private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);



### 快速入门

* 首先要写一个mapper类继承mybatis-plus的BaseMapper（不需要写入@Mapper注解）

  ```java
  @Repository
  public interface UserMapper extends BaseMapper<User>{
      //以下为自定义方法 可以为空
      IPage <User> getList(@Param("page") Page<User> page,@Param("data") User data);
  }
  ```

* 

* 对应的实现类需要继承ServiceImpl，指定泛型中第一个参数为mapper的类，第二个参数是实体类。

  ```java
  // service/impl包下的实现类
  @Service
  public class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService{
      //可以直接使用baseMapper调用方法
      @Override
      IPage <User> getList(@Param("page") Page<User> page,@Param("data") User data){
          return baseMapper.getList(page,data)
      }
  }
  ```

* 在启动类中添加mapper扫描注解：`@MapperScan(packagePath)`    

  注意：这边是填写包路径而不是mapper类的全类名



