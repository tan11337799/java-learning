---
typora-copy-images-to: assets
typora-root-url: assets
---

# 基础

### 计算机网络的体系结构

一般有三种计算机网络的结构：**OSI模型**、**TCP/IP模型**、五层结构（用于学习理解，不展示）

##### OSI 模型

OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。（理论网络通信模型）

- 应用层：通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：**HTTP FTP  SMTP SNMP DNS**.
- 表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
- 会话层：建立、管理、终止会话，是用户应用程序和网络之间的接口。
- 运输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。
- 网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择, 协议有 **ICMP IGMP IP 等**.
- 数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。
- 物理层：建立、维护、断开物理连接。

##### TCP/IP 模型 

（实际的网络通信模型）

- 应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。

- 传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。

- 网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。

- 网络接口层：与 OSI 参考模型的数据链路层、物理层对应。


##### 各层网络协议

<img src="/image-20220625090858137.png" alt="image-20220625090858137" style="zoom:67%;" />



### 传输流程

对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。

- 发送方的应用进程向接收方的应用进程传送数据
- AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元
- 传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元
- 网络层收到这个数据单元后，加上本层的控制信息H3，再交给数据链路层，成为数据链路层的数据单元
- 到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）
- 最后的物理层，进行比特流的传输

下面介绍在传输过程中涉及到的各种部件。



##### DNS解析

DNS，英文全称是 **domain name system**，域名解析系统，它的作用也很明确，就是域名和 IP 相互映射。

具体流程：

- 首先会查找浏览器的缓存和host文件,看看是否能找到**`http://www.baidu.com`**对应的IP地址，找到就直接返回；否则进行下一步。
- 将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；

* 本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责`com`的顶级域名服务器的IP地址的列表。

* 本地DNS服务器再向其中一个负责`com`的顶级域名服务器发送一个请求，返回负责`baidu.com`的权限域名服务器的IP地址列表。

* 本地DNS服务器再向其中一个权限域名服务器发送一个请求，返回**`http://www.baidu.com`**所对应的IP地址。

<img src="/1656082104698.png" alt="1656082104698" style="zoom:67%;" />

##### TCP协议

**（1）数据划分**

HTTP 是基于 TCP 协议传输的，TCP会对数据进行分割，如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。（MTU=MSS+IP头+TCP头）
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

<img src="/image-20220625092958726.png" alt="image-20220625092958726" style="zoom: 67%;" />



**（2）通过三次握手建立连接**

目的：保证收发双方都有发送和接收信息的能力。

<img src="/image-20220625092309694.png" alt="image-20220625092309694" style="zoom:50%;" />

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

**（3）生成TCP报文**

当双方建立连接之后，TCP报文数据就存放了HTTP头+数据。

TCP报文的格式：

<img src="/image-20220625092114396.png" alt="image-20220625092114396" style="zoom:50%;" />

**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序号**，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力。

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

**数据**部分包括HTTP头和应用程序数据块。



##### IP协议

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

**（1）IP包头格式**

<img src="/image-20220625093356230.png" alt="image-20220625093356230" style="zoom:50%;" />

在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：

- 源地址IP，即是客户端输出的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

数据部分包括TCP头部+HTTP头部+应用程序数据

**（2）假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？**

需要根据路由表规则，来判断哪一个网卡作为源地址 IP。

（1）根据路由表的目标地址和掩码计算：将Web服务器的目标地址和路由器中的子网掩码进行与运算，寻找路由表中目的地址相匹配的条目；

（2）将数据转发至匹配条目的gateway地址，如果匹配到的只有目标地址和子网掩码都是0.0.0.0的条目（默认网关），则表示数据传输到了本地局域网，停止转发。



##### MAC地址

网络包的真正构成还需要在IP头前添加MAC头部。（发生在**数据链路层**）

**（1）MAC头**

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

<img src="/image-20220625094515988.png" alt="image-20220625094515988" style="zoom:50%;" />

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

**（2）MAC 发送方和接收方如何确认?**

发送方的MAC地址只需要读取网卡中的ROM。

接收方的MAC地址需要通过多步操作：（1）查询路由表确定接收方的IP；（2）根据ARP协议找到路由器的MAC地址。



##### ARP协议

ARP也叫地址解析协议，是根据IP地址获取物理地址（MAC）的TCP/IP协议。

ARP协议通过在以太网广播的方式，寻找对应IP的设备，进而获取该设备的MAC地址。

在后续操作中操作系统会将每次的查询结果保存在**ARP缓存**中（接收方发现发送方的目标IP与自己一致，则将**发送方**的MAC和IP地址添加到ARP缓存中）。

**查询IP流程：**

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。



##### 网卡

网卡负责将数字信息转换为电信号，使得网络包能在网线上传输。

**网卡驱动程序**则负责控制显卡。网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符（确定包的起始位置），在末尾加上用于检测错误的帧校验序列。

<img src="/image-20220625095550549.png" alt="image-20220625095550549" style="zoom:50%;" />

##### 交换机

交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。交换机中存在**MAC地址表**，用于记录设备MAC地址和交换机端口的对应关系。

功能：交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。

**（1）包接受操作**

首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。（交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址）

**（2）当 MAC 地址表找不到指定的 MAC 地址会怎么样？**

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

**（3）广播地址**

如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`



##### 路由器

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的：

- 因为**路由器**是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。

**（1）路由器基本原理**

路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

**（2）路由器工作过程**

* 电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

* 如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

* 查询路由表确定输出端口：完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。

  > **MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。



# HTTP

### 基本概念

HTTP 是**超文本传输协议**，也就是HyperText Transfer Protocol。

超文本：超越了普通文本的文本，是文字、图片、视频等的混合体，还有超链接（可以实现从一个超文本到另一个超文本的跳转）。

传输：HTTP是计算机中专门用于两点之间传输数据的约定和规范。

协议：HTTP为计算机通信确定了规范，以及各种控制和错误处理方式。



##### 报文结构

HTTP协议的请求报文和响应报文结构基本相同，都由三部分组成：

* 起始行（start line）：描述请求或响应的基本信息；
* 头部字段集合（header）：使用 key-value 形式更详细地说明报文，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。
* 消息正文（entity）：实际传输的数据

**HTTP请求报文：**

![1656170323979](/1656170323979.png)

包含三个部分：1.请求行；2.请求头；3.请求体。

```
GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
空行（CRLF）
报文主体
```

**请求行**展示当前请求的最基本信息，其中包含三个信息：请求的方式（GET/POST/...）、请求的URL、请求的协议（一般是HTTP1.1）

**请求头**通过具体的参数对本次请求进行详细的说明。

**请求体**作为请求的主体，发送数据给服务器。



**HTTP响应报文**

![1656170370173](/1656170370173.png)

包含三个部分：1.响应行；2.响应头；3.响应体。

**响应行（状态行）**包含三个信息：HTTP协议版本、响应状态码、响应状态的文字说明

**响应头**通过具体的参数对本次响应进行详细的说明。

**响应体**是服务器返回的数据主体，可能是各种数据类型。



##### 状态码

大致分类：

- `1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

* `2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。
  * 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
  * 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
  * 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

- `3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。
  - 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URI再次访问。
  - 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    - 301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
  - 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

* `4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。
  * 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
  * 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
  * 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

* `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。
  * 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
  * 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
  * 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
  * 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。



##### 字段

Host字段：在客户端发送请求时，用于指定服务器的域名。

Connection字段：客户端要求服务器使用持久连接，以便其他请求复用。

Content-Length字段：服务器返回数据时，标明本次响应的数据长度。

Content-Type字段：用于服务器返回响应时，告诉客户端，本次数据的格式。

Content-Encoding字段：说明数据的压缩方法。表示服务器返回的数据使用的压缩格式。



### GET和POST

##### 区别

（1）GET请求

GET请求是一种向服务器获取资源的简单请求。GET请求的参数位置写在URL中，因此对参数的编码方式（ASCII）有要求，此外浏览器会对URL的长度有要求。

（2）POST请求

POST请求是根据请求负荷（报文主体）对指定资源进行的处理。请求携带的数据保存在报文主体中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。



##### 安全和幂等

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

在RFC规范定义的语义而言（规定用get进行查询，post进行更新）：

GET 的语义是请求获取指定的资源。**GET 方法是安全、幂等、可被缓存的。**

POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。**POST 不安全，不幂等，（大部分实现）不可缓存。**

原因：

- GET 方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
- POST方法因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。



### 缓存技术







### 版本

关键需要记住 **HTTP/1.0** 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用**多路复用**。

##### HTTP/1.0

- 默认使用**短连接**，每次请求都需要建立一个 TCP 连接。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

- 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。
   
- 分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。
   
- 管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。
   

**HTTP/2.0**

- 二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。
- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。
- 服务端推送，允许服务器未经请求，主动向客户端发送资源。

### **16.HTTP/3了解吗？**

HTTP/3主要有两大变化，**传输层基于UDP**、使用**QUIC保证UDP可靠性**。

HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以HTTP/3在QUIC的基础上进行发展而来，QUIC（Quick UDP Connections）直译为快速UDP网络连接，底层使用UDP进行数据传输。

HTTP/3主要有这些特点：

- 使用UDP作为传输层进行通信
- 在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手
- HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 **3** 次，减少了交互次数。
- QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。