# Spring框架

### 谈一下你对Spring的理解？

需要聊到IOC、AOP、容器、生态、基石

**生态：**Spring作为企业级应用开发的轻量级解决方案，提供了很多个子项目共同构成了Spring的生态体系。

**基石：**的各个组件都依托于Spring进行开发，Spring在整个Spring生态环境中是一个基石的地位。

**容器：**Spring容器是Spring的核心，所有bean对象都存储在容器中，并由IOC进行管理。

Spring中最重要的两个特性是**IOC和AOP**。

**IOC和AOP的作用：**

IOC表示的是控制反转，我们原先需要通过new创建对象，通过IOC我们可以将对象的创建和管理都交给IOC容器进行，

AOP叫面向切面编程，我们可以将与业务逻辑无关的代码（比如日志、权限控制、自动管理）以AOP的方式实现，具体可以通过AOP的消息通知，以具体的前置、后置、环绕等不同的环节中添加与业务无关的代码，完成具体的功能。

**IOC容器的实现：**

Spring容器底层是一个bean工厂，容器中bean的实例化，获取，销毁等操作都由这个bean工厂进行管理。具体的话，Spring提供了两个接口用于实现IOC容器。

第一个是使用BeanFactory，这是IOC容器的基本实现，不提供给开发人员使用。

第二个是ApplicationContext，他是beanFactory的子接口，提供给开发人员使用。


spring如何读取Xml文件和注解信息到容器中？



### spring如何读取xml文件和注解信息到容器中（bean的生命周期）？



（1）xml和注解给出了Bean的定义信息，这些信息会被装载在IOC容器中；

（2）在xml、注解和容器之间存在一个接口BeanDefinitionReader，用于加载解析bean的定义信息，将其封装为IoC 容器内部的数据结构。

（3）在容器中存在一个接口BeanDefinition用于存放这些bean的配置元信息。

（4）（扩展点）BeanDefinition通过若干个BeanFactoryPostProcessor解析定义信息中的占位符等内容。

（5）完成bean对象的初始化操作；

（6）获取完整对象送入容器。

> 反射用法重温：
>
> ```java
> //获取Class对象的三种方式（根据是否存在对象、类名使用）
> Class clazz = Class.forName("全路径");
> Class clazz = object.getClass();
> Class clazz = ClassName.Class(); 
> //获取构造器
> Constructor ctor = clazz.getDeclaredConstructor();
> //创建对象
> Object obj = ctor.newInstance();
> //调用方法
> Method method = clazz.getDeclaredMethod();
> method.invoke(obj,*methodParam);
> ```
>



### 接口和抽象类的区别？

**语法上：**

* 接口可以多实现（多继承），抽象类只能单继承；
* 接口的成员变量都是public的，而抽象类没有这一限制；
* 抽象类可以有具体的实现方法，而接口只能有抽象方法；

**本质上：**

* 接口是自上向下的，从上级出发，不需要考虑具体的子类实现；
* 抽象类是自下向上的，是从子类的角度考虑，将子类的共同点抽象成一个抽象类；



### 详细描述一下bean的生命周期？







---



# Java基础

### 为什么重写equals()方法一定要重写hashCode()方法？两个方法有什么关系？

**关系：**

> - **相同的对象必然导致相同的哈希值；**
> - **不同的哈希值必然是由不同对象导致的；**

如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定相同。

如果两个对象不同，则他们的hashCode不一定不同；

如果两个对象hashCode相同，他们的对象不一定相同；

如果两个对象hashCode不同，他们的对象一定不同。

**重写equals()方法一定要重写hashCode()方法的原因：**

hashCode是根据对象的内存地址经哈希算法得到的，我们通过HashCode方法可以快速确定对象在内存中的存储地址。如果不重写hashCode方法。我们在创建类的多个对象时，jvm就会认为他们存放在一个内存空间中，无法找到对象。





# Java高级

### 多线程

##### 为什么要有线程池？

（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁所造成的消耗；

（2）提高响应速度。当任务到达，任务可以不等待线程创建就直接执行；

（3）提高线程的可管理性。由于线程是稀缺资源，使用线程池可以对限定数量的线程进行统一的分配，调优和监控。进而提高稳定性。



##### 线程池有哪几种？他们各自的特点有哪些？

* newCachedThreadPool：创建一个可缓存的可根据需要创建新线程的线程池。

  特点：

  * 核心线程池数量为0，每次会创建非核心线程执行任务；
  * 线程池中数量没有固定，可达到最大值Integer.MAX_VALUE（易发生OOM）；
  * 线程池中的线程可进行缓存重复利用和回收；

* newFixedThreadPool：创建一个自定义固定核心线程数的线程池，以无界队列的方式运行这些线程。线程池中的线程处于一定的量，因此可以很好的控制线程的并发量。

  特点：

  * 核心线程池数量为n，线程数由用户传入；
  * 超出一定量的线程被提交时候需在队列中等待，队列为无限长度，可以往队列中可以插入无限多的任务（易发生OOM）；

* newSingleThreadExecutor：创建一个单线程线程池，只有一个核心线程，通过以无界队列的方式运行该线程。

  特点：

  * 核心线程池数量为1，每次会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中；
  * 队列为无界队列，可以往队列中可以插入无限多的任务（易发生OOM）；

* newScheduleThreadPool。创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

  特点：

  * 线程池中具有指定数量的线程，即便是空线程也将保留；
  * 可定时或者延迟执行线程活动；

* newSingleThreadScheduleExecutor。创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。

  特点：

  * 线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行；
  * 可定时或者延迟执行线程活动


>  为什么阿里禁用Executors创建线程池，而是推荐自己去创建ThreadPoolExecutor?
>
> - FixedThreadPool和SingleThreadExecutor => 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常
> - CachedThreadPool => 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常



##### 线程池的参数和执行逻辑？

**参数：**

- corePoolSize => 线程池核心线程数量

  > 线程池中会维护一个最小的核心线程数量，即使这些线程处于空闲状态，他们也不会被销毁

- maximumPoolSize => 线程池最大数量

  > 一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了，则会创建一个新线程（非核心线程），然后从工作队列中取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列

- keepAliveTime => 空闲线程存活时间

  > 一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

- unit => keepAliveTime的时间单位

- workQueue => 线程池所使用的缓冲队列

  > 新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列:
  >
  > * ArrayBlockingQueue：基于数组的有界阻塞队列
  > * LinkedBlockingQueue：基于链表的无界阻塞队列
  > * SynchronousQueue：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务
  > * PriorityBlockingQueue：具有优先级的无界阻塞队列

- threadFactory => 线程池创建线程使用的工厂

- handler => 线程池对拒绝任务的处理策略

  - CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大
  - AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。
  - DiscardPolicy - 直接丢弃，其他啥都没有
  - DiscardOldestPolicy - 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入

**执行逻辑：**

- 判断核心线程数是否已满，核心线程数大小和corePoolSize参数有关，未满则创建线程执行任务；
- 若核心线程池已满，判断队列是否满，队列是否满和workQueue参数有关，若未满则加入队列中；
- 若队列已满，判断线程池是否已满，线程池是否已满和maximumPoolSize参数有关，若未满创建线程执行任务；
- 若线程池已满，则采用拒绝策略处理无法执行的任务，拒绝策略和handler参数有关