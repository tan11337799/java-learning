# Spring框架

### 谈一下你对Spring的理解？

需要聊到IOC、AOP、容器、生态、基石

**生态：**Spring作为企业级应用开发的轻量级解决方案，提供了很多个子项目共同构成了Spring的生态体系。

**基石：**的各个组件都依托于Spring进行开发，Spring在整个Spring生态环境中是一个基石的地位。

**容器：**Spring容器是Spring的核心，所有bean对象都存储在容器中，并由IOC进行管理。

Spring中最重要的两个特性是**IOC和AOP**。

**IOC和AOP的作用：**

IOC表示的是控制反转，我们原先需要通过new创建对象，通过IOC我们可以将对象的创建和管理都交给IOC容器进行，

AOP叫面向切面编程，我们可以将与业务逻辑无关的代码（比如日志、权限控制、自动管理）以AOP的方式实现，具体可以通过AOP的消息通知，以具体的前置、后置、环绕等不同的环节中添加与业务无关的代码，完成具体的功能。

**IOC容器的实现：**

Spring容器底层是一个bean工厂，容器中bean的实例化，获取，销毁等操作都由这个bean工厂进行管理。具体的话，Spring提供了两个接口用于实现IOC容器。

第一个是使用BeanFactory，这是IOC容器的基本实现，不提供给开发人员使用。

第二个是ApplicationContext，他是beanFactory的子接口，提供给开发人员使用。


spring如何读取Xml文件和注解信息到容器中？



### spring如何读取xml文件和注解信息到容器中（bean的生命周期）？



（1）xml和注解给出了Bean的定义信息，这些信息会被装载在IOC容器中；

（2）在xml、注解和容器之间存在一个接口BeanDefinitionReader，用于加载解析bean的定义信息，将其封装为IoC 容器内部的数据结构。

（3）在容器中存在一个接口BeanDefinition用于存放这些bean的配置元信息。

（4）（扩展点）BeanDefinition通过若干个BeanFactoryPostProcessor解析定义信息中的占位符等内容。

（5）完成bean对象的初始化操作；

（6）获取完整对象送入容器。

> 反射用法重温：
>
> ```java
> //获取Class对象的三种方式（根据是否存在对象、类名使用）
> Class clazz = Class.forName("全路径");
> Class clazz = object.getClass();
> Class clazz = ClassName.Class(); 
> //获取构造器
> Constructor ctor = clazz.getDeclaredConstructor();
> //创建对象
> Object obj = ctor.newInstance();
> //调用方法
> Method method = clazz.getDeclaredMethod();
> method.invoke(obj,*methodParam);
> ```
>



### 接口和抽象类的区别？

**语法上：**

* 接口可以多实现（多继承），抽象类只能单继承；
* 接口的成员变量都是public的，而抽象类没有这一限制；
* 抽象类可以有具体的实现方法，而接口只能有抽象方法；

**本质上：**

* 接口是自上向下的，从上级出发，不需要考虑具体的子类实现；
* 抽象类是自下向上的，是从子类的角度考虑，将子类的共同点抽象成一个抽象类；



### 详细描述一下bean的生命周期？







---



# Java基础

### 为什么重写equals()方法一定要重写hashCode()方法？两个方法有什么关系？

**关系：**

> - **相同的对象必然导致相同的哈希值；**
> - **不同的哈希值必然是由不同对象导致的；**

如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定相同。

如果两个对象不同，则他们的hashCode不一定不同；

如果两个对象hashCode相同，他们的对象不一定相同；

如果两个对象hashCode不同，他们的对象一定不同。

**重写equals()方法一定要重写hashCode()方法的原因：**

hashCode是根据对象的内存地址经哈希算法得到的，我们通过HashCode方法可以快速确定对象在内存中的存储地址。如果不重写hashCode方法。我们在创建类的多个对象时，jvm就会认为他们存放在一个内存空间中，无法找到对象。





# Java高级

### 多线程

##### 为什么要有线程池？

（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁所造成的消耗；

（2）提高响应速度。当任务到达，任务可以不等待线程创建就直接执行；

（3）提高线程的可管理性。由于线程是稀缺资源，使用线程池可以对限定数量的线程进行统一的分配，调优和监控。进而提高稳定性。



##### 线程池有哪几种？他们各自的特点有哪些？

* newCachedThreadPool：创建一个可缓存的可根据需要创建新线程的线程池。

  特点：

  * 核心线程池数量为0，每次会创建非核心线程执行任务；
  * 线程池中数量没有固定，可达到最大值Integer.MAX_VALUE（易发生OOM）；
  * 线程池中的线程可进行缓存重复利用和回收；

* newFixedThreadPool：创建一个自定义固定核心线程数的线程池，以无界队列的方式运行这些线程。线程池中的线程处于一定的量，因此可以很好的控制线程的并发量。

  特点：

  * 核心线程池数量为n，线程数由用户传入；
  * 超出一定量的线程被提交时候需在队列中等待，队列为无限长度，可以往队列中可以插入无限多的任务（易发生OOM）；

* newSingleThreadExecutor：创建一个单线程线程池，只有一个核心线程，通过以无界队列的方式运行该线程。

  特点：

  * 核心线程池数量为1，每次会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中；
  * 队列为无界队列，可以往队列中可以插入无限多的任务（易发生OOM）；

* newScheduleThreadPool。创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

  特点：

  * 线程池中具有指定数量的线程，即便是空线程也将保留；
  * 可定时或者延迟执行线程活动；

* newSingleThreadScheduleExecutor。创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。

  特点：

  * 线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行；
  * 可定时或者延迟执行线程活动


>  为什么阿里禁用Executors创建线程池，而是推荐自己去创建ThreadPoolExecutor?
>
> - FixedThreadPool和SingleThreadExecutor => 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常
> - CachedThreadPool => 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常



##### 线程池的参数和执行逻辑？

**参数：**

- corePoolSize => 线程池核心线程数量

  > 线程池中会维护一个最小的核心线程数量，即使这些线程处于空闲状态，他们也不会被销毁

- maximumPoolSize => 线程池最大数量

  > 一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了，则会创建一个新线程（非核心线程），然后从工作队列中取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列

- keepAliveTime => 空闲线程存活时间

  > 一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

- unit => keepAliveTime的时间单位

- workQueue => 线程池所使用的缓冲队列

  > 新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列:
  >
  > * ArrayBlockingQueue：基于数组的有界阻塞队列
  > * LinkedBlockingQueue：基于链表的无界阻塞队列
  > * SynchronousQueue：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务
  > * PriorityBlockingQueue：具有优先级的无界阻塞队列

- threadFactory => 线程池创建线程使用的工厂

- handler => 线程池对拒绝任务的处理策略

  - CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大
  - AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。
  - DiscardPolicy - 直接丢弃，其他啥都没有
  - DiscardOldestPolicy - 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入

**执行逻辑：**

- 判断核心线程数是否已满，核心线程数大小和corePoolSize参数有关，未满则创建线程执行任务；
- 若核心线程池已满，判断队列是否满，队列是否满和workQueue参数有关，若未满则加入队列中；
- 若队列已满，判断线程池是否已满，线程池是否已满和maximumPoolSize参数有关，若未满创建线程执行任务；
- 若线程池已满，则采用拒绝策略处理无法执行的任务，拒绝策略和handler参数有关



# 数据库

### Mysql

##### mysql索引的使用有哪些注意事项？

**（1）索引失效的情况：**

* 查询条件包含or，除非每个条件都建有索引，否则索引失效；

* 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效；

* 索引字段上使用is null， is not null，可能导致索引失效；

* 模糊搜索导致的索引失效（当`%`放在匹配字段前是不走索引的，放在后面才会走索引）

* 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效；

* 查询字段为字符串类型，未用引号括起来，索引失效；

* 在索引列上使用mysql的内置函数或进行列运算（如，+、-、*、/），索引失效；

* 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效

* mysql估计使用全表扫描要比使用索引快,则不使用索引；

  > group by和order by的索引规则：
  >
  > 当order by的字段没有出现在where中，则在排序的时候需要正常排序，默认order by是升序排序, 则索引没有对排序产生有利帮助；当order by的字段同时出现在where中，则在获取记录后不进行排序，而是直接利用索引， 效率变高。

**（2）索引的使用场景：**

> 以下情况不建议使用索引

- 数据量少
- 更新比较频繁的也不适合加索引
- 区分度低的字段不适合加索引

**（3）索引规则：**

- 覆盖索引
- 回表
- 索引数据结构（B+树）
- 最左前缀原则
- 索引下推



##### SQL的优化有哪些手段？

**手段：**

- 添加索引

- 适当分批量进行

- 避免查询不必要的数据

- 分库分表

  > 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
  >
  > 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
  >
  > 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
  >
  > 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

- 读写分离

**具体：**

- show status 命令了解各种 sql 的执行频率
- 通过慢查询日志定位那些执行效率较低的 sql 语句
- explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）



##### InnoDB与MyISAM的区别

- 只有InnoDB支持事务；
- 只有InnoDB支持外键；
- 只有InnoDB 支持 MVCC(多版本并发控制)；
- 只有InnoDB支持行级锁，而MyISAM只支持表级锁；
- InnoDB表必须有主键，而MyISAM可以没有主键；
- InnoDB表需要更多的内存和存储用于存储索引和数据，而MyISAM可被压缩，存储空间较小；
- 插入数据时：InnoDB按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存；
- InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些；
- MyISAM有一个变量保存了整个表的总行数，可以直接读取COUNT的值，InnoDB就需要全表扫描；



**为什么索引的数据结构使用B+树，而不是二叉树？**

（1）二叉树每个节点只能存储一个键值和数据，每次查找都需要从磁盘中读取数据，而B类的树在一个节点可以存储多个节点数据，因此树的高度更低，也就降低了读取磁盘的次数。

（2）B+树在B类树中又是最合适的，因为B+树非叶子节点上是不存储数据的，仅存储键值。在innoDB中页的默认大小是16KB，如果不存储数据，那么每个节点就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

（3）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，以链表连接。B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。



##### 聚集索引与非聚集索引的区别？

- 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。
- 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。
- 聚集索引的叶子节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，需要根据该叶子节点中存储的索引找到聚集索引对应的数据块。



##### 事务的四大特点？如何实现？

**四大特点：**

- 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败
- 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态
- 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

**实现：**

原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了ollback，系统通过undo log日志返回事务开始的状态。

持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。

隔离性：通过锁以及MVCC，使事务相互隔离开。

一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。



##### 事务的隔离级别有哪些？分别可以处理哪些并发问题？

| 隔离级别              | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| Read uncommitted      | √    | √          | √    |
| Read committed        | ×    | √          | √    |
| Repeatable Read(默认) | ×    | ×          | √    |
| Serializable          | ×    | ×          | ×    |

##### 并发事务问题分别指什么情况？

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没提交的数据<br />（举例：第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100） |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同<br />（举例：T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同） |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是再insert数据时，又发现这行数据已经存在<br />（举例：T1 读取某个范围的数据，没有对应的数据行；T2 在这个范围内插入新的数据并提交；T1 插入数据时，发现此数据行已存在，进行查询却发现该数据不存在） |

> 幻读和不可重复读的区别：不可重复读是由于另一个事务对数据的UPDATE和DELETE所造成的，而幻读是由于另一个事务INSERT数据引起的